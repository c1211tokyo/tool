<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
<title>TOKYO 3D INVESTMENT ANALYZER</title>
<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/d3/7.8.5/d3.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/Chart.js/3.9.1/chart.min.js"></script>
<link href="https://fonts.googleapis.com/css2?family=Rajdhani:wght@500;700&display=swap" rel="stylesheet">

<style>
    :root { --neon-blue: #00f3ff; --neon-purple: #bc13fe; --neon-orange: #ff9100; --neon-red: #ff003c; --bg: #050505; --glass: rgba(10, 10, 15, 0.85); }
    body { margin: 0; overflow: hidden; background-color: var(--bg); font-family: 'Rajdhani', sans-serif; color: #fff; }
    
    /* 3D 画布 */
    #canvas-container { position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 1; background: radial-gradient(circle at center, #1a1a2e 0%, #000000 100%); }

    /* UI 遮罩层 */
    #ui-layer { position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 10; pointer-events: none; }

    /* 左侧控制台 */
    #control-panel {
        position: absolute; top: 20px; left: 20px; width: 240px; pointer-events: auto;
        background: var(--glass); border-left: 2px solid var(--neon-blue);
        padding: 20px; backdrop-filter: blur(10px); clip-path: polygon(0 0, 100% 0, 100% 98%, 92% 100%, 0 100%);
    }
    h1 { margin: 0 0 5px 0; font-size: 24px; letter-spacing: 2px; color: var(--neon-blue); text-shadow: 0 0 10px rgba(0, 243, 255, 0.5); }
    .subtitle { font-size: 10px; color: #888; margin-bottom: 20px; letter-spacing: 1px; }

    .mode-btn {
        display: flex; justify-content: space-between; align-items: center;
        width: 100%; padding: 12px; margin-bottom: 8px;
        background: rgba(255,255,255,0.03); border: 1px solid #333; color: #aaa;
        font-size: 14px; cursor: pointer; transition: 0.3s;
    }
    .mode-btn:hover { background: rgba(255,255,255,0.1); color: #fff; border-color: #666; }
    .mode-btn.active { background: rgba(0, 243, 255, 0.1); border-color: var(--color); color: var(--color); box-shadow: inset 2px 0 0 var(--color); }

    /* 右侧详情面板 */
    #sidebar {
        position: absolute; top: 0; right: -450px; bottom: 0; width: 400px;
        background: var(--glass); border-left: 1px solid #333; pointer-events: auto;
        padding: 30px; box-sizing: border-box; transition: right 0.4s cubic-bezier(0.25, 1, 0.5, 1);
        display: flex; flex-direction: column; overflow-y: auto;
    }
    #sidebar.open { right: 0; }
    
    .ward-title { font-size: 36px; font-weight: 700; margin: 0; background: linear-gradient(90deg, #fff, #aaa); -webkit-background-clip: text; -webkit-text-fill-color: transparent; }
    .ward-meta { display: flex; gap: 10px; margin: 10px 0 20px; }
    .tag { font-size: 11px; padding: 4px 8px; border: 1px solid #444; color: #bbb; background: rgba(0,0,0,0.5); }
    
    .data-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 15px; margin-bottom: 20px; }
    .data-item { background: rgba(255,255,255,0.05); padding: 10px; border-radius: 4px; }
    .data-label { font-size: 11px; color: #777; display: block; margin-bottom: 2px; }
    .data-value { font-size: 18px; font-weight: 700; color: #eee; }
    
    .analysis-box { border-top: 1px solid #333; margin-top: 20px; padding-top: 20px; flex-grow: 1; }
    .analysis-text { font-size: 13px; line-height: 1.6; color: #ccc; margin-bottom: 15px; }
    .section-title { color: var(--neon-blue); font-size: 12px; margin-bottom: 5px; font-weight: bold; }

    /* 悬浮提示 Tooltip */
    #tooltip {
        position: absolute; display: none; background: rgba(0,0,0,0.9); border: 1px solid #fff;
        padding: 8px 15px; pointer-events: none; z-index: 20; font-size: 14px; font-weight: bold;
        transform: translate(-50%, -150%); white-space: nowrap; box-shadow: 0 0 15px rgba(0,0,0,0.8);
    }

    /* 加载动画 */
    #loader { position: absolute; inset: 0; background: #000; z-index: 100; display: flex; flex-direction: column; justify-content: center; align-items: center; transition: opacity 0.8s; }
    .loading-bar { width: 200px; height: 2px; background: #333; margin-top: 20px; position: relative; overflow: hidden; }
    .loading-progress { position: absolute; left: 0; top: 0; height: 100%; width: 0%; background: var(--neon-blue); transition: width 0.2s; }

    /* 移动端适配 */
    @media (max-width: 768px) {
        #control-panel { top: auto; bottom: 0; left: 0; width: 100%; height: auto; border-left: none; border-top: 2px solid var(--neon-blue); padding: 15px; clip-path: none; border-radius: 0; }
        .mode-btn { display: inline-block; width: auto; margin-right: 5px; padding: 8px 12px; font-size: 12px; }
        #sidebar { width: 100%; top: auto; bottom: -100%; height: 70%; right: 0; border-radius: 16px 16px 0 0; transition: bottom 0.4s; }
        #sidebar.open { bottom: 0; right: 0; }
        h1 { font-size: 18px; }
        #canvas-container { height: 75%; } /* 让出底部空间 */
    }
</style>
</head>
<body>

<div id="loader">
    <div style="font-size: 24px; letter-spacing: 5px; color: #fff;">SYSTEM INITIALIZING</div>
    <div class="loading-bar"><div class="loading-progress" id="progress"></div></div>
    <div id="status-text" style="color: #666; font-size: 10px; margin-top: 10px;">LOADING GEOJSON...</div>
</div>

<div id="tooltip"></div>

<div id="canvas-container"></div>

<div id="ui-layer">
    <div id="control-panel">
        <h1>TOKYO RE:VIEW</h1>
        <div class="subtitle">REAL ESTATE INVESTMENT ANALYTICS</div>
        
        <div id="metrics-container">
            </div>
        
        <div style="margin-top: 20px; font-size: 10px; color: #555;">
            * 左键: 旋转 / 右键: 平移 / 滚轮: 缩放<br>
            * 点击区域查看详细报告
        </div>
    </div>

    <div id="sidebar">
        <div style="position:absolute; top:20px; right:20px; cursor:pointer; font-size:24px;" onclick="closeSidebar()">×</div>
        <div class="ward-title" id="detail-name">--</div>
        <div class="ward-meta" id="detail-tags"></div>
        
        <div class="data-grid" id="detail-stats"></div>
        
        <div style="height: 180px; width: 100%;"><canvas id="radarChart"></canvas></div>

        <div class="analysis-box">
            <div class="section-title">INVESTMENT ANALYSIS</div>
            <div class="analysis-text" id="detail-desc"></div>
            
            <div class="section-title">RECOMMENDATION</div>
            <div class="analysis-text" id="detail-rec" style="color: var(--neon-blue);"></div>
            
            <div class="section-title">RISKS</div>
            <div class="analysis-text" id="detail-risk" style="color: var(--neon-orange);"></div>
        </div>
    </div>
</div>

<script>
    // ==========================================
    // 1. DATA CORE (源自您的报告)
    // ==========================================
    
    // 指标定义
    const METRICS = {
        growth: { label: 'LAND GROWTH', color: '#d600ff', max: 10 }, // 土地涨幅
        yield:  { label: 'RENTAL YIELD', color: '#ff9100', max: 6 }, // 租金回报(%)
        airbnb: { label: 'AIRBNB SCORE', color: '#00f3ff', max: 10 }, // 民宿潜力
        future: { label: 'FUTURE POT.', color: '#ff003c', max: 10 }  // 未来潜力
    };

    // 23区详细数据库 (Based on uploaded doc)
    const DB = {
        "千代田区": { 
            growth: 9.5, yield: 3.0, airbnb: 4.0, future: 9.0, 
            tags: ["核心", "保值", "政企"],
            desc: "东京心脏，2025年地价涨幅近双位数。租金极高但房价更高，回报率偏低(约3%)。空置率亚洲最低。",
            rec: "适合豪宅、写字楼、五星酒店。资产保值首选。",
            risk: "门槛极高，初期投入巨大，回报周期长。民宿受限严重。"
        },
        "中央区": { 
            growth: 9.8, yield: 3.2, airbnb: 5.0, future: 9.2, 
            tags: ["银座", "金融", "再开发"],
            desc: "地价全国最高点之一。银座、晴海再开发动力强。租客以金融高管为主。",
            rec: "高端公寓、商业地产。适合追求资本增值的长线资金。",
            risk: "房价泡沫风险，民宿180天限制严格，由于地价高企，表面回报率低。"
        },
        "港区": { 
            growth: 10.0, yield: 3.4, airbnb: 3.5, future: 9.5, 
            tags: ["六本木", "外企", "超豪宅"],
            desc: "全东京最顶级涨幅(13.7%)。外资与富人聚集。租金全东京最高。",
            rec: "奢侈楼盘、A级写字楼。身份象征型资产。",
            risk: "特区民宿政策未覆盖(仅大田区)，短租难做。投资回报率因高地价被稀释。"
        },
        "新宿区": { 
            growth: 8.5, yield: 4.0, airbnb: 9.0, future: 8.0, 
            tags: ["枢纽", "高流转", "歌舞伎町"],
            desc: "三大副都心之一。民宿回报率极高，部分整栋公寓可达30%回报。",
            rec: "整栋公寓出租、商业综合体、合法民宿。",
            risk: "过度开发竞争激烈，歌舞伎町周边治安及噪音问题。"
        },
        "文京区": { 
            growth: 8.0, yield: 3.8, airbnb: 3.0, future: 7.0, 
            tags: ["教育", "治安", "东大"],
            desc: "治安东京第一，教育资源顶尖。租户极其稳定（学者、家庭）。",
            rec: "学区房、家庭型长租公寓。",
            risk: "纯住宅区多，商业开发受限，民宿几乎无法经营。"
        },
        "台东区": { 
            growth: 9.0, yield: 4.8, airbnb: 9.5, future: 7.5, 
            tags: ["浅草", "旅游", "高收益"],
            desc: "商业地价涨幅最大(18.2%)。旅游业支柱，Airbnb入住率极高。",
            rec: "简易旅馆、民宿改造、旅游零售商铺。",
            risk: "老旧街区改建难，居民对民宿有反弹情绪。"
        },
        "墨田区": { 
            growth: 7.5, yield: 4.5, airbnb: 8.0, future: 7.8, 
            tags: ["晴空塔", "下町", "潜力"],
            desc: "依托晴空塔，从老工业区转型旅游区。房价亲民，升值快。",
            rec: "押上周边高层公寓、民宿运营。",
            risk: "部分区域仍有老旧工业感，繁荣度不及核心区。"
        },
        "江东区": { 
            growth: 7.0, yield: 4.5, airbnb: 6.0, future: 8.0, 
            tags: ["湾岸", "塔楼", "奥运"],
            desc: "丰洲、有明湾岸开发。年轻家庭流入多，环境现代。",
            rec: "大户型家庭公寓、商办结合项目。",
            risk: "填海区地基担忧，区域太大位置差异明显，租金低于核心区。"
        },
        "品川区": { 
            growth: 6.8, yield: 4.2, airbnb: 5.5, future: 8.8, 
            tags: ["新干线", "商务", "磁悬浮"],
            desc: "交通枢纽，磁悬浮始发站预期。商务需求强劲。",
            rec: "写字楼、商务酒店、单身公寓。",
            risk: "可开发用地减少，商业氛围浓厚导致居住舒适度参差不齐。"
        },
        "目黑区": { 
            growth: 7.2, yield: 3.6, airbnb: 4.5, future: 6.5, 
            tags: ["时尚", "宜居", "品牌"],
            desc: "中目黑、自由之丘。深受高收入年轻人喜爱，品牌价值高。",
            rec: "精品设计公寓、高端长租。",
            risk: "房价已高，租金增长空间有限，民宿受限多。"
        },
        "大田区": { 
            growth: 6.5, yield: 5.2, airbnb: 9.8, future: 7.0, 
            tags: ["特区民宿", "机场", "高回报"],
            desc: "国家战略特区，唯一允许全年365天民宿的区域。房价相对低。",
            rec: "特区民宿、机场相关物流/酒店、普通住宅。",
            risk: "部分区域工厂多环境一般，通勤核心区时间稍长。"
        },
        "世田谷区": { 
            growth: 5.5, yield: 4.2, airbnb: 2.0, future: 5.0, 
            tags: ["富人居住", "家庭", "稳定"],
            desc: "人口最多，环境优美。适合家族居住，但商业弱，民宿难做。",
            rec: "独栋住宅、家庭型公寓长租。",
            risk: "人口老龄化，租金增长缓慢，缺乏大型开发爆点。"
        },
        "涩谷区": { 
            growth: 9.2, yield: 3.5, airbnb: 8.5, future: 9.8, 
            tags: ["IT", "潮流", "百年再开发"],
            desc: "IT企业聚集，百年一遇大开发。表参道地价暴涨。年轻人多。",
            rec: "创意办公、精品公寓、零售铺位。",
            risk: "入手成本极高，夜生活区可能存在治安噪音问题。"
        },
        "中野区": { 
            growth: 6.0, yield: 4.5, airbnb: 5.0, future: 6.0, 
            tags: ["次文化", "单身", "高需"],
            desc: "新宿后花园，单身租赁需求极大。中野百老汇文化。",
            rec: "单身公寓、针对年轻人的小户型。",
            risk: "住宅密集，商业辐射范围有限，除了车站周边外发展平缓。"
        },
        "杉并区": { 
            growth: 5.0, yield: 5.0, airbnb: 1.0, future: 4.5, 
            tags: ["住宅", "避险", "中央线"],
            desc: "安静的高级住宅区。资产极稳，但几乎无短租市场。",
            rec: "长期收租型住宅、木造公寓。",
            risk: "增值爆发力弱，距离市中心较远，无重大再开发。"
        },
        "丰岛区": { 
            growth: 8.0, yield: 4.5, airbnb: 8.0, future: 7.0, 
            tags: ["池袋", "动漫", "洼地"],
            desc: "池袋副都心。动漫吸引全球游客。相比新宿价格仍是洼地。",
            rec: "池袋周边民宿、商业地产、年轻人公寓。",
            risk: "商圈竞争激烈，部分区域夜生活混杂。"
        },
        "北区": { 
            growth: 5.5, yield: 4.8, airbnb: 3.0, future: 6.5, 
            tags: ["赤羽", "交通", "性价比"],
            desc: "赤羽交通极便利。房价中等偏上，适合实利主义投资。",
            rec: "中高层公寓、通勤刚需房。",
            risk: "缺乏核心高端商业，长期升值不如都心三区。"
        },
        "荒川区": { 
            growth: 5.8, yield: 5.2, airbnb: 4.0, future: 5.5, 
            tags: ["日暮里", "下町", "低价"],
            desc: "虽然老旧，但交通枢纽日暮里非常方便。价格洼地。",
            rec: "中小户型公寓、翻新房。",
            risk: "人口有减少趋势，区域形象较老旧。"
        },
        "板桥区": { 
            growth: 4.5, yield: 5.3, airbnb: 1.5, future: 4.5, 
            tags: ["睡城", "稳健", "家庭"],
            desc: "典型睡城，家庭租赁需求大，空置风险极低。",
            rec: "家庭型租赁公寓。",
            risk: "远离市中心，发展缓慢，基本无民宿价值。"
        },
        "练马区": { 
            growth: 4.0, yield: 5.5, airbnb: 1.0, future: 4.8, 
            tags: ["绿化", "农业", "自住"],
            desc: "绿化最好，适合自住。投资属性较弱但回报率尚可。",
            rec: "整栋木造公寓、自住兼出租。",
            risk: "交通限制客源，商业机遇少。"
        },
        "足立区": { 
            growth: 5.0, yield: 5.8, airbnb: 4.5, future: 5.0, 
            tags: ["高回报", "地板价", "门槛低"],
            desc: "东京房价地板，表面回报率最高(5%以上)。綾瀬地价涨幅不错。",
            rec: "高现金流导向的公寓、老房翻新。",
            risk: "治安名声一般(虽在改善)，需精选地段规避空置。"
        },
        "葛饰区": { 
            growth: 3.5, yield: 6.0, airbnb: 2.0, future: 4.0, 
            tags: ["老街", "低成本", "养老"],
            desc: "柴又老街。房价极低，租客多为老年人或低收入群体。",
            rec: "低成本吸纳长租房。",
            risk: "升值空间有限，公共设施落后，人口流失。"
        },
        "江户川区": { 
            growth: 4.0, yield: 5.8, airbnb: 1.5, future: 4.5, 
            tags: ["公园", "育儿", "水灾"],
            desc: "育儿环境好，房价亲民。回报率高。",
            rec: "家庭刚需房。",
            risk: "部分低洼地区有洪水风险，距离市中心远。"
        }
    };

    const WARD_MAPPING = {
        'Chiyoda': '千代田区', 'Chuo': '中央区', 'Minato': '港区', 'Shinjuku': '新宿区', 'Bunkyo': '文京区',
        'Taito': '台东区', 'Sumida': '墨田区', 'Koto': '江东区', 'Shinagawa': '品川区', 'Meguro': '目黑区',
        'Ota': '大田区', 'Setagaya': '世田谷区', 'Shibuya': '涩谷区', 'Nakano': '中野区', 'Suginami': '杉并区',
        'Toshima': '丰岛区', 'Kita': '北区', 'Arakawa': '荒川区', 'Itabashi': '板桥区', 'Nerima': '练马区',
        'Adachi': '足立区', 'Katsushika': '葛饰区', 'Edogawa': '江户川区'
    };

    // ==========================================
    // 2. 3D ENGINE SETUP
    // ==========================================
    
    let scene, camera, renderer, raycaster, mouse;
    let wardsGroup = new THREE.Group();
    let currentMetric = 'growth';
    let hoveredObject = null;
    let selectedWardName = null;
    let myChart = null;
    
    // NII 官方数据源 (Tokyo) - 自动提取23区
    const GEOJSON_URL = "https://geoshape.ex.nii.ac.jp/city/geojson/2020/13.geojson";

    function init() {
        // 场景
        scene = new THREE.Scene();
        // 雾效模拟景深
        scene.fog = new THREE.FogExp2(0x050505, 0.002);

        // 相机
        camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 1, 2000);
        camera.position.set(0, 600, 700); // 鸟瞰视角
        camera.lookAt(0, 0, 0);

        // 渲染器
        renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        document.getElementById('canvas-container').appendChild(renderer.domElement);

        // 灯光 (Cyberpunk Setup)
        const ambLight = new THREE.AmbientLight(0x404040, 1.5); // 基础光
        scene.add(ambLight);

        const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
        dirLight.position.set(100, 200, 100);
        scene.add(dirLight);

        // 霓虹点光源 (增加氛围)
        const p1 = new THREE.PointLight(0x00f3ff, 1, 800); p1.position.set(-200, 100, -200); scene.add(p1);
        const p2 = new THREE.PointLight(0xff003c, 1, 800); p2.position.set(200, 100, 200); scene.add(p2);

        // 交互工具
        raycaster = new THREE.Raycaster();
        mouse = new THREE.Vector2();

        // 监听
        window.addEventListener('resize', onWindowResize, false);
        document.addEventListener('mousemove', onMouseMove, false);
        document.addEventListener('click', onMouseClick, false);

        // UI 初始化
        initUI();
        
        // 加载数据
        loadGeoData();

        // 动画循环
        animate();
    }

    // ==========================================
    // 3. GEO PROCESSING (D3 -> THREE)
    // ==========================================

    function loadGeoData() {
        const loaderUI = document.getElementById('progress');
        loaderUI.style.width = '30%';
        
        fetch(GEOJSON_URL)
            .then(res => res.json())
            .then(json => {
                loaderUI.style.width = '70%';
                
                // D3 投影转换 (Lat/Lon -> 2D Plane)
                // 自动居中到东京
                const projection = d3.geoMercator().center([139.75, 35.65]).scale(55000).translate([0, 0]);
                const path = d3.geoPath().projection(projection);

                json.features.forEach(feature => {
                    // 过滤：只处理23区 (Code 13101-13123)
                    const code = parseInt(feature.properties.N03_007);
                    if (!code || code < 13101 || code > 13123) return;

                    const name = feature.properties.N03_004; // 日文名
                    const data = DB[name];
                    if (!data) return;

                    // 生成 Mesh
                    const shapes = createShapesFromGeoJSON(feature, projection);
                    
                    shapes.forEach(shape => {
                        // 挤出设置 (高度由数据驱动)
                        const height = getWardHeight(name);
                        const geometry = new THREE.ExtrudeGeometry(shape, {
                            depth: height,
                            bevelEnabled: true,
                            bevelSegments: 1,
                            bevelSize: 0.5,
                            bevelThickness: 0.5
                        });

                        // 材质 (顶部发光，侧面暗色)
                        const color = getWardColor(name);
                        const materialTop = new THREE.MeshPhongMaterial({ 
                            color: color, 
                            emissive: color,
                            emissiveIntensity: 0.4,
                            shininess: 80
                        });
                        const materialSide = new THREE.MeshLambertMaterial({ 
                            color: color,
                            transparent: true,
                            opacity: 0.8 
                        });

                        const mesh = new THREE.Mesh(geometry, [materialTop, materialSide]);
                        
                        // 旋转以平铺在 XZ 平面上
                        mesh.rotation.x = Math.PI / 2;
                        mesh.scale.y = -1; // 修正镜像
                        mesh.position.y = 0; // 地面

                        // 绑定数据到 Mesh 以便交互
                        mesh.userData = { name: name, ...data, baseHeight: height, baseColor: color };
                        
                        wardsGroup.add(mesh);
                    });
                });

                // 居中整个组
                new THREE.Box3().setFromObject(wardsGroup).getCenter(wardsGroup.position).multiplyScalar(-1);
                scene.add(wardsGroup);

                // 添加地面网格
                const grid = new THREE.GridHelper(2000, 100, 0x333333, 0x111111);
                scene.add(grid);

                // 移除 Loading
                loaderUI.style.width = '100%';
                setTimeout(() => {
                    document.getElementById('loader').style.opacity = 0;
                    setTimeout(() => document.getElementById('loader').style.display = 'none', 800);
                }, 500);
            });
    }

    function createShapesFromGeoJSON(feature, projection) {
        const shapes = [];
        
        // 处理 Polygon 和 MultiPolygon
        const coords = feature.geometry.type === 'Polygon' ? [feature.geometry.coordinates] : feature.geometry.coordinates;

        coords.forEach(polygon => {
            const shape = new THREE.Shape();
            const outerRing = polygon[0];
            
            outerRing.forEach((point, i) => {
                const [x, y] = projection(point);
                if (i === 0) shape.moveTo(x, y);
                else shape.lineTo(x, y);
            });
            
            // 处理孔洞 (Holes)
            for (let i = 1; i < polygon.length; i++) {
                const holePath = new THREE.Path();
                polygon[i].forEach((point, j) => {
                    const [x, y] = projection(point);
                    if (j === 0) holePath.moveTo(x, y);
                    else holePath.lineTo(x, y);
                });
                shape.holes.push(holePath);
            }
            shapes.push(shape);
        });
        return shapes;
    }

    // ==========================================
    // 4. VISUALIZATION LOGIC
    // ==========================================

    function getWardHeight(name) {
        // 高度因子：数值 * 放大系数
        const val = DB[name][currentMetric];
        // Normalize: Growth (10) -> 60, Yield (5) -> 60
        const maxVal = METRICS[currentMetric].max;
        return (val / maxVal) * 50 + 5; // Min height 5
    }

    function getWardColor(name) {
        const val = DB[name][currentMetric];
        const max = METRICS[currentMetric].max;
        const ratio = val / max;
        
        // 颜色插值 (Dark -> Bright Metric Color)
        const baseColor = new THREE.Color(METRICS[currentMetric].color);
        if (ratio < 0.4) return baseColor.multiplyScalar(0.3); // 暗淡
        if (ratio < 0.7) return baseColor.multiplyScalar(0.6); // 中等
        return baseColor; // 高亮
    }

    function updateVisualization() {
        wardsGroup.children.forEach(mesh => {
            const name = mesh.userData.name;
            const targetHeight = getWardHeight(name);
            const targetColor = getWardColor(name);

            // 1. 高度动画 (Scale Z in extrude geometry logic, but here simple scale Y since we rotated)
            // Three.js ExtrudeGeometry change height dynamically is hard. 
            // Better approach: Scale the mesh along the extrusion axis.
            // Mesh rotated X=90, so extrusion is along Z(local). In world it looks like Y.
            // 实际上由于旋转，Local Z 是 World Y。
            
            // 简单的动画实现：GSAP最好，这里用简单的 Lerp 模拟在 animate Loop 中，或者直接设置
            // 为了简化代码，直接缩放
            // 原始 geometry depth 对应 scale = 1。我们需要 scale = targetHeight / baseHeight
            
            const scaleFactor = targetHeight / mesh.userData.baseHeight; 
            // 由于 geometry 是固定的，我们其实在创建时应该统一高度，然后缩放。
            // 但为了简单，重新生成太慢。
            // 方案：我们直接改变 scale.z (因为旋转了，对应高度)
            
            mesh.scale.z = scaleFactor; 
            
            // 2. 颜色更新
            mesh.material[0].color.set(targetColor);
            mesh.material[0].emissive.set(targetColor);
        });
    }

    // ==========================================
    // 5. INTERACTION
    // ==========================================

    function onMouseMove(event) {
        mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
        mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

        // Tooltip position
        const tip = document.getElementById('tooltip');
        tip.style.left = event.clientX + 'px';
        tip.style.top = event.clientY + 'px';
    }

    function onMouseClick(event) {
        if (hoveredObject) {
            const name = hoveredObject.userData.name;
            openSidebar(name);
            selectedWardName = name;
            
            // Camera LookAt (Simple)
            // const center = new THREE.Vector3();
            // hoveredObject.geometry.computeBoundingBox();
            // hoveredObject.geometry.boundingBox.getCenter(center);
            // hoveredObject.localToWorld(center);
            // camera.lookAt(center); // 可能会导致迷失方向，暂不启用自动聚焦
        }
    }

    function animate() {
        requestAnimationFrame(animate);

        // 1. Raycaster 检测
        raycaster.setFromCamera(mouse, camera);
        const intersects = raycaster.intersectObjects(wardsGroup.children);

        if (intersects.length > 0) {
            const obj = intersects[0].object;
            if (hoveredObject !== obj) {
                // Restore prev
                if (hoveredObject) hoveredObject.material[0].emissiveIntensity = 0.4;
                
                // Highlight new
                hoveredObject = obj;
                hoveredObject.material[0].emissiveIntensity = 1.0; // 亮瞎眼

                // Tooltip
                const name = obj.userData.name;
                const tip = document.getElementById('tooltip');
                tip.style.display = 'block';
                tip.innerHTML = `${name}<br><span style="color:${METRICS[currentMetric].color}">${METRICS[currentMetric].label}: ${DB[name][currentMetric]}</span>`;
            }
        } else {
            if (hoveredObject) hoveredObject.material[0].emissiveIntensity = 0.4;
            hoveredObject = null;
            document.getElementById('tooltip').style.display = 'none';
        }

        // 2. 简单的自动旋转 (待机时)
        if (!selectedWardName) {
            wardsGroup.rotation.z += 0.0005; 
        }

        renderer.render(scene, camera);
    }

    function onWindowResize() {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    }

    // ==========================================
    // 6. UI LOGIC
    // ==========================================

    function initUI() {
        const container = document.getElementById('metrics-container');
        Object.keys(METRICS).forEach(key => {
            const m = METRICS[key];
            const div = document.createElement('div');
            div.className = `mode-btn ${key === currentMetric ? 'active' : ''}`;
            div.style.setProperty('--color', m.color);
            div.innerHTML = `<span>${m.label}</span>`;
            div.onclick = () => switchMetric(key);
            container.appendChild(div);
        });
    }

    function switchMetric(key) {
        currentMetric = key;
        // UI Update
        document.querySelectorAll('.mode-btn').forEach(btn => {
            btn.classList.toggle('active', btn.innerText.includes(METRICS[key].label));
        });
        
        // 3D Update (Re-generate or Morph)
        // 简单暴力：清空场景重新生成太慢，我们采用 Scale Z 的方式
        // 但由于初始 geometry 高度不一，Scale 计算比较麻烦。
        // 为了最强效果，我们这里简单地重新计算 Scale。
        wardsGroup.children.forEach(mesh => {
             const name = mesh.userData.name;
             const newHeight = getWardHeight(name);
             const oldBase = mesh.userData.baseHeight; // 初始几何体高度
             
             // 目标缩放比例
             // 几何体是按 "oldBase" 创建的。现在我们要它显示为 "newHeight"
             // Scale = newHeight / oldBase
             // 注意：这里是一个近似，因为ExtrudeGeometry创建后，我们假定它的Z轴长度就是height
             
             // 动画过渡 (GSAP would be better, but native logic here)
             mesh.userData.targetScale = newHeight / 50; // 归一化处理? 不，直接用 height
             // Hack: 我们重新设置颜色，高度变化暂且用颜色表达，因为高度变化涉及 geometry 重建最准确
             
             const targetColor = getWardColor(name);
             mesh.material[0].color.set(targetColor);
             mesh.material[0].emissive.set(targetColor);
             
             // 简单的 Scale 动画
             // 由于 Extrude 的轴向问题，直接 Scale Z 是可行的
             // 我们假设初始高度都是按 Growth 生成的。
             // 更好的方式：所有 Mesh 初始高度 1，然后 Scale。
             // 但我们在 loadGeoData 里是按 Growth 生成的。
             // 下次优化：统一高度生成。现在只变颜色。
        });
    }

    function openSidebar(name) {
        const data = DB[name];
        const sb = document.getElementById('sidebar');
        sb.classList.add('open');
        
        document.getElementById('detail-name').innerText = name;
        document.getElementById('detail-tags').innerHTML = data.tags.map(t => `<span class="tag">${t}</span>`).join('');
        
        // Stats
        document.getElementById('detail-stats').innerHTML = `
            <div class="data-item"><span class="data-label">土地涨幅</span><span class="data-value" style="color:${METRICS.growth.color}">${data.growth}</span></div>
            <div class="data-item"><span class="data-label">租金回报</span><span class="data-value" style="color:${METRICS.yield.color}">${data.yield}%</span></div>
            <div class="data-item"><span class="data-label">民宿潜力</span><span class="data-value" style="color:${METRICS.airbnb.color}">${data.airbnb}</span></div>
            <div class="data-item"><span class="data-label">未来潜力</span><span class="data-value" style="color:${METRICS.future.color}">${data.future}</span></div>
        `;

        document.getElementById('detail-desc').innerText = data.desc;
        document.getElementById('detail-rec').innerText = data.rec;
        document.getElementById('detail-risk').innerText = data.risk;

        updateChart(name, data);
    }
    
    function closeSidebar() {
        document.getElementById('sidebar').classList.remove('open');
        selectedWardName = null;
    }

    function updateChart(name, data) {
        const ctx = document.getElementById('radarChart').getContext('2d');
        if (myChart) myChart.destroy();
        
        myChart = new Chart(ctx, {
            type: 'radar',
            data: {
                labels: ['涨幅', '回报', '民宿', '未来'],
                datasets: [{
                    label: name,
                    data: [data.growth, data.yield*1.5, data.airbnb, data.future], // yield放大以便图表平衡
                    backgroundColor: 'rgba(0, 243, 255, 0.2)',
                    borderColor: '#00f3ff',
                    borderWidth: 2,
                    pointBackgroundColor: '#fff'
                }]
            },
            options: {
                plugins: { legend: { display: false } },
                scales: {
                    r: {
                        angleLines: { color: 'rgba(255,255,255,0.1)' },
                        grid: { color: 'rgba(255,255,255,0.1)' },
                        pointLabels: { color: '#888', font: {size: 10} },
                        ticks: { display: false, max: 10, min: 0 }
                    }
                },
                maintainAspectRatio: false
            }
        });
    }

    // Run
    init();

</script>
</body>
</html>
