<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>AI NEXUS: Deep Space Edition</title>
    <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@500;800&family=Rajdhani:wght@400;600&display=swap" rel="stylesheet">
    <style>
        :root {
            --bg-deep: #020207;
            --nebula-1: rgba(92, 26, 234, 0.12);
            --nebula-2: rgba(0, 243, 255, 0.08);
            --nebula-3: rgba(255, 60, 172, 0.05);
        }

        * {
            margin: 0; padding: 0; box-sizing: border-box;
            user-select: none; -webkit-tap-highlight-color: transparent;
        }

        body {
            width: 100vw; height: 100vh;
            background-color: var(--bg-deep);
            overflow: hidden;
            font-family: 'Rajdhani', sans-serif;
            position: relative;
            /* 深空基底 */
            background-image: radial-gradient(circle at center, #1a1a2e 0%, #000000 80%);
        }

        /* --- 背景层：宏伟动态星云 --- */
        .nebula-container {
            position: absolute; width: 100%; height: 100%;
            filter: blur(60px); /* 极度模糊制造气态感 */
            z-index: 0; opacity: 0.8;
            will-change: transform;
        }

        .nebula-layer {
            position: absolute; top: -50%; left: -50%; width: 200%; height: 200%;
            background-size: 100% 100%;
            animation-timing-function: linear;
            animation-iteration-count: infinite;
        }

        /* 星云层1: 紫色系，顺时针慢转 */
        .nl-1 {
            background: radial-gradient(ellipse at 30% 40%, var(--nebula-1) 0%, transparent 60%),
                        radial-gradient(ellipse at 70% 60%, var(--nebula-1) 0%, transparent 50%);
            animation: nebulaSpin 120s infinite;
        }
        /* 星云层2: 青色系，逆时针更慢转 */
        .nl-2 {
            background: radial-gradient(ellipse at 60% 30%, var(--nebula-2) 0%, transparent 60%),
                        radial-gradient(ellipse at 20% 70%, var(--nebula-2) 0%, transparent 50%);
            animation: nebulaSpin 180s reverse infinite;
        }

        @keyframes nebulaSpin {
            from { transform: rotate(0deg); } to { transform: rotate(360deg); }
        }

        /* --- 背景层：星空与流星 --- */
        #stars-container {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 1;
        }
        .star {
            position: absolute; background: white; border-radius: 50%;
            box-shadow: 0 0 3px rgba(255,255,255,0.8);
            animation: twinkle infinite alternate;
        }
        @keyframes twinkle { 0% { opacity: 0.2; transform: scale(0.8); } 100% { opacity: 1; transform: scale(1.1); } }

        /* 流星 */
        .shooting-star {
            position: absolute;
            top: 50%; left: 50%;
            width: 4px; height: 4px;
            background: linear-gradient(to right, rgba(255,255,255,1), transparent);
            border-radius: 50%;
            box-shadow: 0 0 20px rgba(255,255,255,0.8);
            animation: shoot 5s linear infinite;
            opacity: 0;
        }
        @keyframes shoot {
            0% { transform: translate(0, 0) rotate(-45deg) scale(1); opacity: 1; }
            20% { transform: translate(400px, 400px) rotate(-45deg) scale(0.1); opacity: 0; }
            100% { opacity: 0; }
        }

        /* 舞台 */
        #stage {
            position: relative; width: 100%; height: 100%; z-index: 10;
        }

        /* --- 核心圆球 (精进版) --- */
        .orb {
            position: absolute;
            border-radius: 50%;
            /* 更高级的玻璃质感底色 */
            background: rgba(15, 20, 35, 0.35);
            /* 更厚的毛玻璃效果 */
            backdrop-filter: blur(12px);
            -webkit-backdrop-filter: blur(12px);
            /* 精致的边框 */
            border: 1px solid rgba(255, 255, 255, 0.25);
            border-bottom-color: rgba(255, 255, 255, 0.1); /* 底部暗淡增加立体感 */
            
            /* 复杂的光影层 */
            box-shadow: 
                inset 0 0 40px rgba(120, 150, 255, 0.1), /* 内部柔光 */
                0 0 25px var(--glow-color), /* 外部核心霓虹光 */
                0 10px 30px rgba(0,0,0,0.6); /* 底部投影增加悬浮感 */

            display: flex; flex-direction: column; justify-content: center; align-items: center;
            cursor: pointer;
            /* 只对必要的属性做过渡，防止物理引擎冲突 */
            transition: box-shadow 0.3s ease, border-color 0.3s ease; 
            will-change: transform;
            /* 移除了那个丑陋的 ::after 白色椭圆高光 */
        }

        .orb img {
            width: 58%; height: 58%;
            object-fit: contain; pointer-events: none; z-index: 2;
            filter: drop-shadow(0 0 8px rgba(255,255,255,0.3)); /* Logo自带微光 */
            transition: opacity 0.2s;
        }

        /* 兜底文字 */
        .orb-fallback-text {
            font-family: 'Orbitron', sans-serif; font-size: 2.5rem; font-weight: 800; color: rgba(255,255,255,0.8);
        }

        /* 悬浮信息 */
        .orb-info {
            position: absolute; bottom: -65px; left: 50%; transform: translateX(-50%);
            width: 220px; text-align: center; opacity: 0; pointer-events: none;
            transition: opacity 0.3s cubic-bezier(0.4, 0, 0.2, 1); z-index: 20;
            background: rgba(0, 0, 0, 0.85);
            border: 1px solid var(--glow-color); padding: 8px 12px; border-radius: 6px;
            box-shadow: 0 5px 15px rgba(0,0,0,0.5);
        }
        /* 信息框小三角指示器 */
        .orb-info::after {
            content:''; position:absolute; top:-6px; left:50%; margin-left:-6px;
            border-width:0 6px 6px; border-style:solid; border-color:transparent transparent var(--glow-color);
        }

        .orb-name {
            font-family: 'Orbitron', sans-serif; font-size: 16px; font-weight: 800;
            letter-spacing: 1px; color: var(--glow-color); text-transform: uppercase;
        }
        .orb-desc {
            font-family: 'Rajdhani', sans-serif; font-size: 12px; font-weight: 600; color: #aaa; margin-top: 3px;
        }

        /* --- 交互状态 --- */

        /* 悬停：更亮的边缘和光晕，物理引擎控制 scale */
        .orb.hovered {
            z-index: 1000 !important;
            border-color: rgba(255,255,255,0.9);
            box-shadow: 
                0 0 60px var(--glow-color), 
                inset 0 0 40px rgba(255, 255, 255, 0.3);
        }
        .orb.hovered .orb-info { opacity: 1; bottom: -75px; /* 悬浮时信息框稍微下移一点 */ }

        /* --- 核心：黑洞吸入动画 (修复跳动和效果) --- */
        .orb.blackhole-active {
            z-index: 9999 !important;
            /* 使用 cubic-bezier 实现先向外爆发再猛烈坍缩的效果 */
            animation: gravitationalCollapse 0.7s cubic-bezier(0.6, -0.28, 0.735, 0.045) forwards;
        }
        
        /* 点击瞬间 Logo 立刻消失 */
        .orb.blackhole-active img { opacity: 0 !important; }
        .orb.blackhole-active .orb-info { opacity: 0 !important; display: none; }

        @keyframes gravitationalCollapse {
            0% {
                transform: scale(1.2); /* 初始状态：稍微放大 */
                background: #000; border-color: #fff;
                box-shadow: 0 0 50px var(--glow-color), inset 0 0 50px #000;
            }
            30% {
                 /* 爆发阶段：视界扩张 */
                transform: scale(1.5);
                background: #000; border-color: var(--glow-color);
                box-shadow: 0 0 150px var(--glow-color), inset 0 0 20px #fff;
            }
            100% {
                /* 坍缩阶段：消失于一点 */
                transform: scale(0.01) rotate(360deg);
                background: #000; border-color: #000;
                box-shadow: 0 0 0px #000;
                opacity: 0;
            }
        }

        /* 其他球被吸入/变暗淡 */
        .orb.sucked {
            transition: transform 0.6s ease-in, opacity 0.6s ease-in;
            transform: scale(0.2) !important; /* 变小 */
            opacity: 0;
            filter: grayscale(1); /* 失去色彩 */
        }

        /* 底部标识 */
        .footer-mark {
            position: absolute; bottom: 15px; width: 100%; text-align: center;
            color: rgba(255, 255, 255, 0.3); font-family: 'Orbitron', sans-serif;
            font-size: 10px; letter-spacing: 3px; z-index: 5; pointer-events: none;
        }
    </style>
</head>
<body>

    <div class="nebula-container">
        <div class="nebula-layer nl-1"></div>
        <div class="nebula-layer nl-2"></div>
    </div>
    <div id="stars-container">
        <div class="shooting-star" style="top: 20%; left: 30%; animation-delay: 2s;"></div>
        <div class="shooting-star" style="top: 60%; left: 70%; animation-delay: 7s;"></div>
    </div>

    <div id="stage"></div>

    <div class="footer-mark">NEXUS PORTAL // SUYU.2025</div>

    <script>
        // ================= 数据配置 =================
        const aiTools = [
            { name: "ChatGPT", id: "gpt", url: "https://chat.openai.com", color: "#10a37f", desc: "OpenAI 通用对话巨头" },
            { name: "Gemini", id: "gemini", url: "https://gemini.google.com", color: "#4E86F5", desc: "Google 原生多模态" },
            { name: "Claude", id: "claude", url: "https://claude.ai", color: "#d97757", desc: "Anthropic 长文本专家" },
            { name: "DeepSeek", id: "deepseek", url: "https://www.deepseek.com", color: "#4b6bfb", desc: "开源编码与推理新星" },
            { name: "Perplexity", id: "perplexity", url: "https://www.perplexity.ai", color: "#24bba1", desc: "AI 驱动的精准搜索" },
            { name: "Grok", id: "grok", url: "https://grok.x.ai", color: "#ffffff", desc: "X 平台实时资讯大模型" },
            { name: "Meta AI", id: "meta", url: "https://www.meta.ai", color: "#0064e0", desc: "Llama 开源生态基石" },
            { name: "Copilot", id: "microsoft", url: "https://copilot.microsoft.com", color: "#2E89F3", desc: "微软办公生产力整合" },
            { name: "Midjourney", id: "midjourney", url: "https://www.midjourney.com", color: "#ffffff", desc: "顶级艺术图像生成" },
            { name: "Sora", id: "sora", url: "https://openai.com/sora", color: "#ff3366", desc: "物理世界视频模拟器" },
            { name: "Runway", id: "runway", url: "https://runwayml.com", color: "#c9fa4c", desc: "专业级 AI 视频编辑" },
            { name: "HuggingFace", id: "huggingface", url: "https://huggingface.co", color: "#ffd21e", desc: "全球 AI 模型开源社区" },
            { name: "Ollama", id: "ollama", url: "https://ollama.com", color: "#ffffff", desc: "本地大模型运行框架" },
            { name: "Qwen", id: "qwenr", url: "https://www.qianwen.com", color: "#615ced", desc: "通义千问全家桶" },
            { name: "Ernie", id: "wenxin", url: "https://yiyan.baidu.com", color: "#0057ff", desc: "百度文心知识增强" }
        ];

        // ================= 引擎逻辑 =================
        const stage = document.getElementById('stage');
        const starsContainer = document.getElementById('stars-container');
        const orbs = [];
        let isTransitioning = false; // 全局状态锁

        // 1. 初始化星空 (更密集、更多层次)
        function initStars() {
            const count = 150; // 增加星星数量
            for (let i = 0; i < count; i++) {
                const star = document.createElement('div');
                star.className = 'star';
                // 随机大小，制造景深感
                const sizeBase = Math.random();
                let size;
                if (sizeBase > 0.9) size = 2.5 + Math.random(); // 少数大星
                else if (sizeBase > 0.6) size = 1.5 + Math.random(); // 中星
                else size = 0.5 + Math.random(); // 大量微星

                star.style.width = `${size}px`; star.style.height = `${size}px`;
                star.style.left = `${Math.random() * 100}%`; star.style.top = `${Math.random() * 100}%`;
                star.style.opacity = 0.3 + Math.random() * 0.7;
                star.style.animationDuration = `${3 + Math.random() * 5}s`;
                star.style.animationDelay = `${Math.random() * 5}s`;
                starsContainer.appendChild(star);
            }
        }

        // 2. Orb 类定义
        class Orb {
            constructor(data, index) {
                this.data = data;
                // 尺寸适配：PC端稍微加大一点，更有气势
                const isMobile = window.innerWidth < 768;
                const baseSize = isMobile ? 85 : 140;
                this.realRadius = (baseSize * (0.85 + Math.random() * 0.3)) / 2;
                this.radius = this.realRadius; // 物理半径
                
                // 初始位置尽量分散
                this.x = Math.random() * (window.innerWidth - this.realRadius * 2);
                this.y = Math.random() * (window.innerHeight - this.realRadius * 2);
                
                // 速度更缓慢沉稳
                const v = isMobile ? 0.25 : 0.4;
                this.vx = (Math.random() - 0.5) * v;
                this.vy = (Math.random() - 0.5) * v;

                this.element = document.createElement('div');
                this.imgElement = null; // 引用图片元素以便快速操作
                this.initDOM();
                
                this.isHovered = false;
                this.scale = 1; // JS控制的缩放倍率
            }

            initDOM() {
                this.element.className = 'orb';
                this.element.style.width = `${this.realRadius * 2}px`;
                this.element.style.height = `${this.realRadius * 2}px`;
                this.element.style.setProperty('--glow-color', this.data.color);

                // 图片
                this.imgElement = document.createElement('img');
                this.imgElement.src = `pic/${this.data.id}.png`;
                this.imgElement.onerror = () => {
                    this.imgElement.style.display = 'none';
                    const txt = document.createElement('div');
                    txt.className = 'orb-fallback-text';
                    txt.innerText = this.data.name[0];
                    this.element.appendChild(txt);
                };
                this.element.appendChild(this.imgElement);

                // 信息框
                const info = document.createElement('div');
                info.className = 'orb-info';
                info.innerHTML = `
                    <div class="orb-name">${this.data.name}</div>
                    <div class="orb-desc">${this.data.desc}</div>
                `;
                this.element.appendChild(info);

                // 事件绑定
                this.element.addEventListener('mouseenter', () => this.onEnter());
                this.element.addEventListener('mouseleave', () => this.onLeave());
                this.element.addEventListener('click', () => this.onClick());
                this.element.addEventListener('touchstart', (e) => this.onEnter(), {passive: true});

                stage.appendChild(this.element);
            }

            onEnter() {
                if (isTransitioning) return;
                this.isHovered = true;
                this.element.classList.add('hovered');
                this.scale = 1.15; // 悬停轻微放大
            }

            onLeave() {
                if (isTransitioning) return;
                this.isHovered = false;
                this.element.classList.remove('hovered');
                this.scale = 1;
            }

            onClick() {
                if (isTransitioning) return;
                isTransitioning = true; // 上锁

                // 【关键修复：防止跳动】
                // 点击瞬间，立刻锁定当前计算出的绝对位置到内联样式
                // 这样 CSS 动画接管时，起始点就是当前位置，而不是默认的左上角 (0,0)
                this.element.style.left = `${this.x}px`;
                this.element.style.top = `${this.y}px`;
                // 暂时移除 JS 的 transform 控制，交给 CSS 动画
                this.element.style.transform = 'none'; 

                // 触发黑洞动画
                this.element.classList.add('blackhole-active');
                
                // 其他球被吸入
                orbs.forEach(o => {
                    if (o !== this) o.element.classList.add('sucked');
                });

                // 延迟跳转 (等待吸入动画基本完成)
                setTimeout(() => {
                    window.open(this.data.url, '_blank');
                }, 700);

                // 自动复原 (3秒后，足够用户在新页面浏览一会)
                setTimeout(() => {
                    this.reset();
                }, 3000);
            }

            // 【关键修复：状态复位】
            reset() {
                isTransitioning = false; // 解锁

                orbs.forEach(o => {
                    // 强制清除所有过渡状态类名
                    o.element.classList.remove('blackhole-active', 'sucked', 'hovered');
                    o.isHovered = false;
                    o.scale = 1;
                    // 确保图片重新显示
                    if (o.imgElement) o.imgElement.style.opacity = ''; 

                    // 【关键】：清除刚才为了锁定位置添加的内联样式
                    // 这样下一帧 JS 物理循环就能重新接管位置控制
                    o.element.style.left = '';
                    o.element.style.top = '';
                    // 手动触发一次位置更新，防止闪烁
                    o.updateRenderer();
                });
            }

            updatePhysics() {
                if (isTransitioning) return;

                // 悬停时停止运动，作为物理墙壁
                if (this.isHovered) {
                    this.vx = 0; this.vy = 0;
                } else {
                    this.x += this.vx; this.y += this.vy;
                    // 边界碰撞反弹
                    if (this.x <= 0) { this.x = 0; this.vx *= -1; }
                    if (this.x + this.realRadius * 2 >= window.innerWidth) { 
                        this.x = window.innerWidth - this.realRadius * 2; this.vx *= -1; 
                    }
                    if (this.y <= 0) { this.y = 0; this.vy *= -1; }
                    if (this.y + this.realRadius * 2 >= window.innerHeight) { 
                        this.y = window.innerHeight - this.realRadius * 2; this.vy *= -1; 
                    }
                }
            }

            updateRenderer() {
                 if (isTransitioning) return;
                 // 使用 JS 控制位置和缩放
                 this.element.style.transform = `translate3d(${this.x}px, ${this.y}px, 0) scale(${this.scale})`;
            }
        }

        // 3. 主循环
        function loop() {
            if (!isTransitioning) {
                // A. 物理计算：球体间碰撞
                for (let i = 0; i < orbs.length; i++) {
                    for (let j = i + 1; j < orbs.length; j++) {
                        const b1 = orbs[i]; const b2 = orbs[j];
                        const dx = (b2.x + b2.realRadius) - (b1.x + b1.realRadius);
                        const dy = (b2.y + b2.realRadius) - (b1.y + b1.realRadius);
                        const dist = Math.sqrt(dx * dx + dy * dy);
                        const minDist = b1.realRadius + b2.realRadius;

                        if (dist < minDist) {
                            const angle = Math.atan2(dy, dx);
                            const overlap = minDist - dist + 0.5;
                            const moveX = (overlap / 2) * Math.cos(angle);
                            const moveY = (overlap / 2) * Math.sin(angle);

                            // 处理悬停球体(墙壁)的情况
                            if (b1.isHovered && !b2.isHovered) {
                                b2.x += moveX * 2; b2.y += moveY * 2;
                                b2.vx = Math.abs(b2.vx) * Math.cos(angle) * 1.5;
                                b2.vy = Math.abs(b2.vy) * Math.sin(angle) * 1.5;
                            } else if (!b1.isHovered && b2.isHovered) {
                                b1.x -= moveX * 2; b1.y -= moveY * 2;
                                b1.vx = -Math.abs(b1.vx) * Math.cos(angle) * 1.5;
                                b1.vy = -Math.abs(b1.vy) * Math.sin(angle) * 1.5;
                            } else if (!b1.isHovered && !b2.isHovered) {
                                b1.x -= moveX; b1.y -= moveY;
                                b2.x += moveX; b2.y += moveY;
                                // 简单动量交换
                                const tvx = b1.vx; const tvy = b1.vy;
                                b1.vx = b2.vx; b1.vy = b2.vy;
                                b2.vx = tvx; b2.vy = tvy;
                            }
                        }
                    }
                }
                // B. 更新物理位置
                orbs.forEach(o => o.updatePhysics());
            }
            
            // C. 渲染更新 (始终运行，确保 reset 时能立刻刷新)
            orbs.forEach(o => o.updateRenderer());
            requestAnimationFrame(loop);
        }

        // 初始化
        initStars();
        aiTools.forEach((data, i) => orbs.push(new Orb(data, i)));
        loop();

        // 窗口调整适配
        window.addEventListener('resize', () => {
             orbs.forEach(o => {
                 o.x = Math.min(o.x, window.innerWidth - o.realRadius*2);
                 o.y = Math.min(o.y, window.innerHeight - o.realRadius*2);
             })
        });

    </script>
</body>
</html>
