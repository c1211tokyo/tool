<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>AI NEXUS: Matrix Edition</title>
    <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@500;700&family=Rajdhani:wght@500;700&display=swap" rel="stylesheet">
    <style>
        :root {
            /* 极致深黑背景 */
            --bg-deep: #000000; 
            /* 极微弱的星云色 */
            --nebula-1: rgba(30, 30, 45, 0.4); 
            --nebula-2: rgba(10, 15, 25, 0.3); 
        }

        * {
            margin: 0; padding: 0; box-sizing: border-box;
            user-select: none; -webkit-tap-highlight-color: transparent;
        }

        body {
            width: 100vw; height: 100vh;
            background-color: var(--bg-deep);
            overflow: hidden;
            font-family: 'Rajdhani', sans-serif;
            position: relative;
            background-image: radial-gradient(circle at center, #0b0b14 0%, #000000 90%);
        }

        /* --- 背景层：星云 --- */
        .nebula-container {
            position: absolute; width: 100%; height: 100%;
            filter: blur(90px); z-index: 0; opacity: 0.5; pointer-events: none;
        }

        .nebula-layer {
            position: absolute; top: -50%; left: -50%; width: 200%; height: 200%;
            background-size: 100% 100%;
            animation-timing-function: linear;
            animation-iteration-count: infinite;
        }

        .nl-1 {
            background: radial-gradient(ellipse at 40% 40%, var(--nebula-1) 0%, transparent 50%);
            animation: nebulaSpin 150s infinite;
        }
        .nl-2 {
            background: radial-gradient(ellipse at 60% 60%, var(--nebula-2) 0%, transparent 50%);
            animation: nebulaSpin 200s reverse infinite;
        }

        @keyframes nebulaSpin { from { transform: rotate(0deg); } to { transform: rotate(360deg); } }

        /* 星星容器 (静态星 + 动态流星) */
        #stars-container {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 1; pointer-events: none;
        }
        .star {
            position: absolute; background: white; border-radius: 50%;
            opacity: 0.8; animation: twinkle infinite alternate;
        }
        @keyframes twinkle { 0% { opacity: 0.3; } 100% { opacity: 1; } }

        /* 流星样式 */
        .shooting-star-trail {
            position: absolute;
            height: 2px;
            background: linear-gradient(to right, rgba(255,255,255,0), rgba(255,255,255,1));
            border-radius: 50%;
            box-shadow: 0 0 10px rgba(255,255,255,0.8);
            opacity: 0;
            z-index: 2; /* 确保在星云之上 */
            pointer-events: none;
            /* 动画由JS动态插入 */
        }

        /* 舞台 */
        #stage {
            position: relative; width: 100%; height: 100%; z-index: 10;
        }

        /* --- 核心：Liquid Glass (液态玻璃) 样式优化 --- */
        .orb {
            position: absolute;
            border-radius: 50%;
            /* 1. 调亮底色：增加不透明度，偏冷白，不再死黑 */
            background: rgba(220, 235, 255, 0.08); 
            
            /* 2. 混合模式：提高饱和度和亮度 */
            backdrop-filter: blur(10px) saturate(150%) brightness(1.1); 
            -webkit-backdrop-filter: blur(10px) saturate(150%) brightness(1.1);
            
            /* 3. 光影层：增强轮廓光 */
            box-shadow: 
                inset 0 0 20px rgba(255, 255, 255, 0.1), /* 内部辉光 */
                inset 2px 4px 8px rgba(255, 255, 255, 0.25), /* 顶部高光 */
                inset -2px -4px 10px rgba(0, 0, 0, 0.5), /* 底部阴影 */
                0 0 15px var(--glow-color-dim); /* 外部辉光 */

            border: 1px solid rgba(255, 255, 255, 0.25); /* 边框更明显 */
            border-top: 1px solid rgba(255, 255, 255, 0.5); /* 顶边框加强 */
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);

            display: flex; flex-direction: column; justify-content: center; align-items: center;
            cursor: pointer;
            
            transition: box-shadow 0.4s ease, border-color 0.4s ease, filter 0.4s ease;
            will-change: transform;
        }

        /* 高光点 */
        .orb::after {
            content: ''; position: absolute;
            top: 8%; left: 15%; width: 40%; height: 25%;
            border-radius: 50%;
            background: radial-gradient(ellipse at center, rgba(255,255,255,0.95) 0%, rgba(255,255,255,0) 70%);
            transform: rotate(-45deg); opacity: 0.7; pointer-events: none;
        }

        .orb img {
            width: 55%; height: 55%;
            object-fit: contain; pointer-events: none; z-index: 2;
            filter: drop-shadow(0 4px 8px rgba(0,0,0,0.4));
            transition: transform 0.3s;
        }

        /* 悬浮信息 */
        .orb-info {
            position: absolute; bottom: -60px; left: 50%; transform: translateX(-50%);
            width: 180px; text-align: center; opacity: 0; pointer-events: none;
            transition: opacity 0.3s; z-index: 20;
            background: rgba(15, 15, 20, 0.9); backdrop-filter: blur(10px);
            border: 1px solid rgba(255,255,255,0.2); border-radius: 8px;
            padding: 6px 10px;
        }
        .orb-name { font-family: 'Orbitron', sans-serif; font-size: 14px; color: #fff; letter-spacing: 1px; }
        .orb-desc { font-size: 10px; color: #ccc; }

        /* --- 交互状态 --- */
        .orb.hovered {
            z-index: 1000 !important;
            border-color: rgba(255,255,255,0.9);
            background: rgba(220, 235, 255, 0.15); /* 悬浮时更亮 */
            box-shadow: 
                inset 0 0 30px rgba(255, 255, 255, 0.3),
                0 0 60px var(--glow-color); 
        }
        .orb.hovered img { transform: scale(1.1); }
        .orb.hovered .orb-info { opacity: 1; bottom: -70px; }

        /* 黑洞特效 */
        .orb.blackhole-active { z-index: 9999 !important; animation: blackhole 0.8s cubic-bezier(0.7,0,0.2,1) forwards; }
        @keyframes blackhole {
            0% { transform: scale(1.2); filter: brightness(2); }
            40% { transform: scale(0.1); filter: brightness(50); background: #fff; } 
            100% { transform: scale(0); opacity: 0; }
        }
        .orb.sucked { transition: transform 0.6s ease, opacity 0.6s; transform: scale(0.3) !important; opacity: 0; }

        /* --- UI控件：归位按钮 --- */
        .control-btn {
            position: absolute; bottom: 25px; left: 25px;
            width: 48px; height: 48px;
            border-radius: 14px;
            background: rgba(255, 255, 255, 0.08);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.2);
            display: flex; justify-content: center; align-items: center;
            cursor: pointer; z-index: 100;
            transition: all 0.3s ease;
            color: rgba(255,255,255,0.7);
        }
        .control-btn:hover {
            background: rgba(255, 255, 255, 0.2);
            border-color: rgba(255, 255, 255, 0.6);
            color: #fff; transform: scale(1.05);
            box-shadow: 0 0 20px rgba(255,255,255,0.15);
        }
        .control-btn svg { width: 22px; height: 22px; fill: currentColor; }

        .footer-mark {
            position: absolute; bottom: 25px; right: 25px;
            color: rgba(255, 255, 255, 0.25); font-family: 'Orbitron', sans-serif;
            font-size: 11px; letter-spacing: 2px; z-index: 5; pointer-events: none;
        }

    </style>
</head>
<body>

    <div class="nebula-container">
        <div class="nebula-layer nl-1"></div>
        <div class="nebula-layer nl-2"></div>
    </div>
    <div id="stars-container"></div>

    <div id="stage"></div>

    <div class="control-btn" id="dock-btn" title="矩阵归位 / 自由漂浮">
        <svg viewBox="0 0 24 24"><path d="M4 4h4v4H4zm6 0h4v4h-4zm6 0h4v4h-4zM4 10h4v4H4zm6 0h4v4h-4zm6 0h4v4h-4zM4 16h4v4H4zm6 0h4v4h-4zm6 0h4v4h-4z"/></svg>
    </div>

    <div class="footer-mark">SUYU.2025</div>

    <script>
        // ================= 数据 =================
        const aiTools = [
            { name: "ChatGPT", id: "gpt", url: "https://chat.openai.com", color: "#10a37f", desc: "OpenAI 智能助手" },
            { name: "Gemini", id: "gemini", url: "https://gemini.google.com", color: "#4E86F5", desc: "Google 多模态 AI" },
            { name: "Claude", id: "claude", url: "https://claude.ai", color: "#d97757", desc: "Anthropic 长文本" },
            { name: "DeepSeek", id: "deepseek", url: "https://www.deepseek.com", color: "#4b6bfb", desc: "深度求索" },
            { name: "Perplexity", id: "perplexity", url: "https://www.perplexity.ai", color: "#24bba1", desc: "AI 搜索" },
            { name: "Grok", id: "grok", url: "https://grok.x.ai", color: "#ffffff", desc: "X 平台实时 AI" },
            { name: "Meta AI", id: "meta", url: "https://www.meta.ai", color: "#0064e0", desc: "Llama 生态" },
            { name: "Copilot", id: "microsoft", url: "https://copilot.microsoft.com", color: "#2E89F3", desc: "Microsoft 助手" },
            { name: "Midjourney", id: "midjourney", url: "https://www.midjourney.com", color: "#ffffff", desc: "AI 绘画" },
            { name: "Sora", id: "sora", url: "https://openai.com/sora", color: "#ff3366", desc: "视频生成" },
            { name: "Runway", id: "runway", url: "https://runwayml.com", color: "#c9fa4c", desc: "视频编辑" },
            { name: "HuggingFace", id: "huggingface", url: "https://huggingface.co", color: "#ffd21e", desc: "开源社区" },
            { name: "Ollama", id: "ollama", url: "https://ollama.com", color: "#ffffff", desc: "本地运行" },
            { name: "Qwen", id: "qwenr", url: "https://tongyi.aliyun.com", color: "#615ced", desc: "通义千问" },
            { name: "Ernie", id: "wenxin", url: "https://yiyan.baidu.com", color: "#0057ff", desc: "文心一言" }
        ];

        // ================= 引擎核心 =================
        const stage = document.getElementById('stage');
        const starsContainer = document.getElementById('stars-container');
        const dockBtn = document.getElementById('dock-btn');
        const orbs = [];
        
        let isTransitioning = false;
        let isDocked = false;

        // 1. 静态背景星初始化
        function initStars() {
            const count = 120;
            for (let i = 0; i < count; i++) {
                const s = document.createElement('div');
                s.className = 'star';
                const size = Math.random() * 2;
                s.style.width = size + 'px'; s.style.height = size + 'px';
                s.style.left = Math.random() * 100 + '%'; s.style.top = Math.random() * 100 + '%';
                s.style.animationDuration = (2 + Math.random() * 3) + 's';
                starsContainer.appendChild(s);
            }
        }

        // 2. 动态流星系统 (修复可见性)
        function spawnShootingStar() {
            const star = document.createElement('div');
            star.className = 'shooting-star-trail';
            
            // 随机起始位置 (主要在右上方或左上方)
            const startX = Math.random() * window.innerWidth;
            const startY = Math.random() * (window.innerHeight * 0.5);
            
            // 随机长度和角度
            const length = 100 + Math.random() * 200;
            const angle = 45; // 向右下角划过
            
            star.style.width = length + 'px';
            star.style.left = startX + 'px';
            star.style.top = startY + 'px';
            star.style.transform = `rotate(${angle}deg)`;
            
            // 动态注入动画
            star.animate([
                { transform: `translate(0, 0) rotate(${angle}deg)`, opacity: 0 },
                { transform: `translate(100px, 100px) rotate(${angle}deg)`, opacity: 1, offset: 0.1 },
                { transform: `translate(600px, 600px) rotate(${angle}deg)`, opacity: 0 }
            ], {
                duration: 1500 + Math.random() * 1000,
                easing: 'ease-out'
            }).onfinish = () => star.remove();

            starsContainer.appendChild(star);

            // 随机时间再次生成
            setTimeout(spawnShootingStar, 2000 + Math.random() * 4000);
        }

        class Orb {
            constructor(data, index) {
                this.data = data;
                
                // 【修改点】三种固定大小 logic
                const isMobile = window.innerWidth < 768;
                // 定义三种基准尺寸 (半径)
                // Desktop: 大=70(宽140), 中=55(宽110), 小=45(宽90)
                // Mobile: 大=45(宽90), 中=38(宽76), 小=30(宽60)
                const sizes = isMobile ? [30, 38, 45] : [45, 55, 70];
                // 随机分配一个尺寸等级 (0:小, 1:中, 2:大)
                this.sizeTier = Math.floor(Math.random() * 3);
                this.realRadius = sizes[this.sizeTier];
                this.radius = this.realRadius;
                
                // 初始位置
                this.x = Math.random() * (window.innerWidth - this.realRadius * 2);
                this.y = Math.random() * (window.innerHeight - this.realRadius * 2);
                
                const v = 0.5;
                this.vx = (Math.random() - 0.5) * v;
                this.vy = (Math.random() - 0.5) * v;

                this.targetX = 0;
                this.targetY = 0;
                this.element = null;
                this.imgElement = null;
                this.isHovered = false;
                this.scale = 1;
                this.hoverTimer = null;
                
                this.initDOM();
            }

            initDOM() {
                this.element = document.createElement('div');
                this.element.className = 'orb';
                this.element.style.width = this.realRadius * 2 + 'px';
                this.element.style.height = this.realRadius * 2 + 'px';
                
                this.element.style.setProperty('--glow-color', this.data.color);
                this.element.style.setProperty('--glow-color-dim', this.data.color + '40'); 

                this.imgElement = document.createElement('img');
                this.imgElement.src = `pic/${this.data.id}.png`;
                this.imgElement.onerror = () => {
                    this.imgElement.style.display = 'none';
                    const t = document.createElement('div');
                    t.innerText = this.data.name[0];
                    t.style.fontSize = '1.8em'; t.style.color = 'rgba(255,255,255,0.7)'; t.style.fontWeight = 'bold';
                    this.element.appendChild(t);
                };
                this.element.appendChild(this.imgElement);

                const info = document.createElement('div');
                info.className = 'orb-info';
                info.innerHTML = `<div class="orb-name">${this.data.name}</div><div class="orb-desc">${this.data.desc}</div>`;
                this.element.appendChild(info);

                this.element.addEventListener('mouseenter', () => this.onEnter());
                this.element.addEventListener('mouseleave', () => this.onLeave());
                this.element.addEventListener('touchstart', () => this.onEnter(), {passive: true});
                this.element.addEventListener('click', () => this.onClick());

                stage.appendChild(this.element);
            }

            onEnter() {
                if (isTransitioning) return;
                this.isHovered = true;
                this.element.classList.add('hovered');
                this.scale = 1.15;
                
                if (!isDocked) {
                    if (this.hoverTimer) clearTimeout(this.hoverTimer);
                    this.hoverTimer = setTimeout(() => this.triggerShockwave(), 3000);
                }
            }

            onLeave() {
                if (isTransitioning) return;
                this.isHovered = false;
                this.element.classList.remove('hovered');
                this.scale = 1;
                if (this.hoverTimer) clearTimeout(this.hoverTimer);
            }

            triggerShockwave() {
                if (!this.isHovered || isTransitioning || isDocked) return;
                const force = 12;
                orbs.forEach(t => {
                    if (t === this) return;
                    const dx = (t.x + t.realRadius) - (this.x + this.realRadius);
                    const dy = (t.y + t.realRadius) - (this.y + this.realRadius);
                    const dist = Math.sqrt(dx*dx + dy*dy);
                    if (dist > 0) {
                        t.vx += (dx/dist) * force;
                        t.vy += (dy/dist) * force;
                    }
                });
            }

            onClick() {
                if (isTransitioning) return;
                isTransitioning = true;
                if (this.hoverTimer) clearTimeout(this.hoverTimer);

                this.element.style.left = this.x + 'px';
                this.element.style.top = this.y + 'px';
                this.element.style.transform = 'none';

                this.element.classList.add('blackhole-active');
                orbs.forEach(o => { if (o !== this) o.element.classList.add('sucked'); });

                setTimeout(() => window.open(this.data.url, '_blank'), 800);
                setTimeout(() => this.reset(), 3000);
            }

            reset() {
                isTransitioning = false;
                orbs.forEach(o => {
                    if (o.hoverTimer) clearTimeout(o.hoverTimer);
                    o.element.classList.remove('blackhole-active', 'sucked', 'hovered');
                    o.isHovered = false;
                    o.scale = 1;
                    if(o.imgElement) o.imgElement.style.opacity = '';
                    o.element.style.left = ''; o.element.style.top = '';
                    o.updateRenderer();
                });
            }

            updateDocking() {
                const easing = 0.05; 
                this.x += (this.targetX - this.x) * easing;
                this.y += (this.targetY - this.y) * easing;
                this.vx = 0; this.vy = 0;
            }

            updatePhysics() {
                if (this.isHovered) return;
                this.x += this.vx; this.y += this.vy;

                if (this.x <= 0) { this.x = 0; this.vx *= -1; }
                if (this.x + this.realRadius*2 >= window.innerWidth) { this.x = window.innerWidth - this.realRadius*2; this.vx *= -1; }
                if (this.y <= 0) { this.y = 0; this.vy *= -1; }
                if (this.y + this.realRadius*2 >= window.innerHeight) { this.y = window.innerHeight - this.realRadius*2; this.vy *= -1; }
            }

            updateRenderer() {
                if (isTransitioning) return;
                this.element.style.transform = `translate3d(${this.x}px, ${this.y}px, 0) scale(${this.scale})`;
            }
        }

        // ================= 归位计算逻辑 (核心修改) =================
        function calculateDockPositions() {
            // 1. 排序：按尺寸从小到大 (小球在前，大球在后)
            // 这样我们在填充行时，先填充第一行(小)，最后填充最后一行(大)
            // 从而实现：小球在上面，大球在下面
            const sortedOrbs = [...orbs].sort((a, b) => a.realRadius - b.realRadius);

            const isMobile = window.innerWidth < 768;
            const gap = isMobile ? 8 : 15; // 间距
            const bottomMargin = 100; // 距离底部
            
            // 我们固定分 3 排
            const rowCount = 3;
            const itemsPerRow = Math.ceil(sortedOrbs.length / rowCount); // 计算每排大概多少个(约5个)

            // 计算所有行的总高度，以便垂直居中或贴底
            // 但需求是 "靠底"，所以我们从下往上计算 Y
            
            let currentIdx = 0;
            
            // 遍历每一排 (Row 0 是最上面/小球，Row 2 是最下面/大球)
            for (let r = 0; r < rowCount; r++) {
                // 取出这一排的球
                // 注意：如果总数除不尽，最后一排(大球)可能会少几个，或者第一排少几个
                // 为了让大球沉底且填满，我们建议平均分配
                
                // 截取当前行的球
                const start = r * itemsPerRow;
                const end = Math.min(start + itemsPerRow, sortedOrbs.length);
                const rowOrbs = sortedOrbs.slice(start, end);
                
                if (rowOrbs.length === 0) continue;

                // 计算这一排的总宽度，用于水平居中
                let rowWidth = 0;
                rowOrbs.forEach(o => rowWidth += (o.realRadius * 2 + gap));
                rowWidth -= gap; // 减去最后一个多余间距

                let startX = (window.innerWidth - rowWidth) / 2;
                
                // 计算这一排的 Y 坐标
                // 既然 Row 0 是小球(上)，Row 2 是大球(下)
                // 我们需要确定每一排的高度基准
                // 简单起见，设定固定行高或基于该行最大球体
                // 这里我们倒着算 Y：从屏幕底部往上推
                
                // 重新思考：Row 2 (大) 在最下面。
                // 屏幕底部位置
                // Y offset from bottom: 
                // Row 2 Y = H - bottomMargin - rowHeight
                // Row 1 Y = Row 2 Y - gap - rowHeight
                // ...
                
                // 为了简单，我们手动指定每一排距离底部的距离
                // Row 0 (Top/Small): Bottom + 250
                // Row 1 (Mid/Mid): Bottom + 140
                // Row 2 (Btm/Large): Bottom + 20
                // 具体数值根据球体大小动态算
                
                // 这里我们统一用一种从上往下排列的思路，然后整体往下压
                // 或者直接按顺序排，因为我们已经把 array sort 好了 (小->大)
                
            }

            // 重新实作：按 "排" 分配
            // Row 0 (Top): Smallest
            // Row 1 (Mid): Medium
            // Row 2 (Btm): Largest
            
            // 预设行高中心线距离底部的距离
            const rowBottomOffsets = isMobile ? [220, 140, 60] : [300, 180, 60]; 
            
            for (let r = 0; r < rowCount; r++) {
                const start = r * itemsPerRow;
                const end = Math.min(start + itemsPerRow, sortedOrbs.length);
                const rowOrbs = sortedOrbs.slice(start, end);
                
                if (rowOrbs.length === 0) continue;

                let rowWidth = 0;
                rowOrbs.forEach(o => rowWidth += (o.realRadius * 2 + gap));
                rowWidth -= gap;

                let currentX = (window.innerWidth - rowWidth) / 2;
                // Y 坐标：屏幕高度 - 预设的偏移量 - 球半径(因为y是左上角)
                // rowBottomOffsets[0] 是最上面的行(距离底部最远)
                // 但我们的数组 rowBottomOffsets[0] 写的是 220，是最大的，刚好对应
                // 实际上 r=0 是小球，rowBottomOffsets[0] 应该是最高的距离
                
                // 修正：sortedOrbs 是 小->大
                // r=0 处理小球，放在最上面 (距离底部远)
                // r=2 处理大球，放在最下面 (距离底部近)
                // rowBottomOffsets 需要是 [远, 中, 近] -> [300, 180, 60]
                
                const bottomOffset = rowBottomOffsets[r] || 60; 
                const centerY = window.innerHeight - bottomOffset;

                rowOrbs.forEach(orb => {
                    orb.targetX = currentX;
                    orb.targetY = centerY - orb.realRadius; // 居中修正
                    
                    currentX += (orb.realRadius * 2 + gap);
                });
            }
        }

        dockBtn.addEventListener('click', () => {
            isDocked = !isDocked;
            dockBtn.style.opacity = isDocked ? '1' : '0.6';
            dockBtn.style.color = isDocked ? '#fff' : 'rgba(255,255,255,0.7)';
            
            if (isDocked) {
                calculateDockPositions();
            } else {
                orbs.forEach(o => {
                    o.vx = (Math.random() - 0.5) * 2;
                    o.vy = (Math.random() - 0.5) * 2;
                });
            }
        });

        window.addEventListener('resize', () => {
            if (isDocked) calculateDockPositions();
        });


        // ================= 主循环 =================
        function loop() {
            if (!isTransitioning) {
                if (isDocked) {
                    orbs.forEach(o => o.updateDocking());
                } else {
                    // 碰撞检测
                    for (let i = 0; i < orbs.length; i++) {
                        for (let j = i + 1; j < orbs.length; j++) {
                            const b1 = orbs[i]; const b2 = orbs[j];
                            const dx = (b2.x + b2.realRadius) - (b1.x + b1.realRadius);
                            const dy = (b2.y + b2.realRadius) - (b1.y + b1.realRadius);
                            const dist = Math.sqrt(dx*dx + dy*dy);
                            const minDist = b1.realRadius + b2.realRadius;

                            if (dist < minDist) {
                                const angle = Math.atan2(dy, dx);
                                const overlap = minDist - dist + 0.5;
                                const moveX = (overlap/2) * Math.cos(angle);
                                const moveY = (overlap/2) * Math.sin(angle);

                                if (b1.isHovered && !b2.isHovered) {
                                    b2.x += moveX*2; b2.y += moveY*2;
                                    b2.vx = Math.abs(b2.vx)*Math.cos(angle)*1.5; b2.vy = Math.abs(b2.vy)*Math.sin(angle)*1.5;
                                } else if (!b1.isHovered && b2.isHovered) {
                                    b1.x -= moveX*2; b1.y -= moveY*2;
                                    b1.vx = -Math.abs(b1.vx)*Math.cos(angle)*1.5; b1.vy = -Math.abs(b1.vy)*Math.sin(angle)*1.5;
                                } else if (!b1.isHovered && !b2.isHovered) {
                                    b1.x -= moveX; b1.y -= moveY; b2.x += moveX; b2.y += moveY;
                                    const tvx = b1.vx; const tvy = b1.vy; b1.vx = b2.vx; b1.vy = b2.vy; b2.vx = tvx; b2.vy = tvy;
                                }
                            }
                        }
                    }
                    orbs.forEach(o => o.updatePhysics());
                }
            }
            orbs.forEach(o => o.updateRenderer());
            requestAnimationFrame(loop);
        }

        initStars();
        spawnShootingStar(); // 启动流星
        aiTools.forEach((d, i) => orbs.push(new Orb(d, i)));
        loop();

    </script>
</body>
</html>
