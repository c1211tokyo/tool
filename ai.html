<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>AI NEXUS - 2025</title>
    <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700&family=Rajdhani:wght@300;500&display=swap" rel="stylesheet">
    <style>
        :root {
            --bg-color: #030305;
            --grid-color: rgba(64, 224, 255, 0.15);
            --neon-blue: #00f3ff;
            --neon-purple: #bc13fe;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            user-select: none;
            -webkit-tap-highlight-color: transparent;
        }

        body {
            width: 100vw;
            height: 100vh;
            background-color: var(--bg-color);
            /* 深空渐变 */
            background-image: radial-gradient(circle at 50% -20%, #1a1a3a 0%, #000000 100%);
            overflow: hidden;
            font-family: 'Rajdhani', sans-serif;
            position: relative;
        }

        /* --- 视觉层1：移动的透视网格 (Retro-wave Grid) --- */
        .cyber-grid {
            position: absolute;
            bottom: 0;
            left: 0;
            width: 100%;
            height: 35%; /* 只占据底部 */
            background: 
                linear-gradient(transparent 0%, var(--grid-color) 2%, transparent 3%),
                linear-gradient(90deg, transparent 0%, var(--grid-color) 2%, transparent 3%);
            background-size: 40px 40px; /* 网格大小 */
            transform: perspective(500px) rotateX(60deg); /* 3D透视 */
            transform-origin: bottom center;
            opacity: 0.5;
            z-index: 0;
            /* 模拟网格移动 */
            animation: gridMove 20s linear infinite;
        }
        
        @keyframes gridMove {
            0% { background-position: 0 0; }
            100% { background-position: 0 1000px; }
        }
        
        /* 远处的地平线光辉 */
        .horizon-glow {
            position: absolute;
            bottom: 20%;
            left: 0;
            width: 100%;
            height: 100px;
            background: radial-gradient(ellipse at center, rgba(0, 243, 255, 0.15) 0%, transparent 70%);
            z-index: 0;
            pointer-events: none;
        }

        /* --- 视觉层2：全息扫描线 (Scanlines) --- */
        .scanlines {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(to bottom, rgba(255,255,255,0), rgba(255,255,255,0) 50%, rgba(0,0,0,0.2) 50%, rgba(0,0,0,0.2));
            background-size: 100% 4px;
            pointer-events: none;
            z-index: 999; /* 最顶层覆盖 */
            opacity: 0.3;
        }

        /* 星空背景 */
        #stars-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 0;
        }
        .star {
            position: absolute;
            background: white;
            border-radius: 50%;
            box-shadow: 0 0 4px #fff;
            animation: twinkle infinite alternate;
        }
        @keyframes twinkle {
            0% { opacity: 0.3; }
            100% { opacity: 1; }
        }

        /* 舞台 */
        #stage {
            position: relative;
            width: 100%;
            height: 100%;
            z-index: 10;
        }

        /* --- 核心圆球 --- */
        .orb {
            position: absolute;
            border-radius: 50%;
            
            /* 高科技玻璃质感 */
            background: rgba(10, 20, 40, 0.4);
            backdrop-filter: blur(8px);
            -webkit-backdrop-filter: blur(8px);
            
            border: 1px solid rgba(255, 255, 255, 0.3);
            /* 内外发光 */
            box-shadow: 
                inset 0 0 20px rgba(255, 255, 255, 0.1),
                0 0 15px var(--glow-color); /* 外部霓虹光 */

            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            cursor: pointer;
            
            /* 修复抖动：移除 transform 的 transition，改用 JS 驱动每一帧，除了 opacity/filter */
            transition: box-shadow 0.3s ease, border-color 0.3s ease, transform 0.1s linear; 
            will-change: transform, left, top;
        }

        /* 内部高光反射 */
        .orb::after {
            content: '';
            position: absolute;
            top: 10%;
            left: 10%;
            width: 30%;
            height: 15%;
            border-radius: 50%;
            background: linear-gradient(135deg, rgba(255,255,255,0.8) 0%, rgba(255,255,255,0) 100%);
            opacity: 0.6;
            pointer-events: none;
        }

        .orb img {
            width: 60%;
            height: 60%;
            object-fit: contain;
            pointer-events: none; /* 关键：防止鼠标悬停在图片上时触发多次重绘 */
            z-index: 2;
            filter: drop-shadow(0 0 5px rgba(255,255,255,0.3));
        }

        /* 兜底文字 */
        .orb-fallback-text {
            font-family: 'Orbitron', sans-serif;
            font-size: 2rem;
            font-weight: 700;
            color: rgba(255,255,255,0.9);
            text-shadow: 0 0 10px var(--glow-color);
        }

        /* 悬浮信息面板 */
        .orb-info {
            position: absolute;
            bottom: -60px; /* 距离球体更远一点 */
            left: 50%;
            transform: translateX(-50%);
            width: 240px;
            text-align: center;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.2s;
            z-index: 20;
            
            background: rgba(0, 0, 0, 0.8);
            border: 1px solid var(--glow-color);
            padding: 8px;
            border-radius: 4px;
        }

        /* 装饰线连接球体和信息框 */
        .orb-info::before {
            content: '';
            position: absolute;
            top: -10px;
            left: 50%;
            transform: translateX(-50%);
            border-width: 0 6px 10px 6px;
            border-style: solid;
            border-color: transparent transparent var(--glow-color) transparent;
        }

        .orb-name {
            font-family: 'Orbitron', sans-serif;
            font-size: 18px;
            letter-spacing: 2px;
            color: var(--neon-blue);
            text-shadow: 0 0 8px var(--neon-blue);
            text-transform: uppercase;
        }
        
        .orb-desc {
            font-size: 12px;
            color: #ccc;
            margin-top: 4px;
        }

        /* --- 交互状态 --- */

        /* 悬停增强 */
        .orb.hovered {
            z-index: 1000 !important;
            border-color: #fff;
            box-shadow: 
                0 0 50px var(--glow-color), 
                inset 0 0 30px rgba(255, 255, 255, 0.4);
            /* 注意：这里不使用 transform: scale，而在 JS 里处理大小，防止物理引擎抖动 */
        }

        .orb.hovered .orb-info {
            opacity: 1;
        }

        /* 黑洞点击效果 */
        .orb.blackhole-active {
            z-index: 9999 !important;
            animation: singularity 0.8s forwards ease-in-out;
        }

        .orb.blackhole-active::before {
            content: '';
            position: absolute;
            top: 50%; left: 50%;
            transform: translate(-50%, -50%);
            width: 100%; height: 100%;
            background: black;
            border-radius: 50%;
            animation: expandBlack 1s forwards;
        }

        @keyframes singularity {
            0% { transform: scale(1) rotate(0deg); }
            40% { transform: scale(0.5) rotate(-180deg); } /* 坍缩 */
            100% { transform: scale(4) rotate(720deg); opacity: 0; } /* 爆发并消失 */
        }

        /* 其他球被吸入 */
        .orb.sucked {
            transition: all 0.5s ease-in;
            transform: scale(0) !important;
            opacity: 0;
        }

        /* 底部标识 */
        .footer-mark {
            position: absolute;
            bottom: 10px;
            right: 20px;
            text-align: right;
            color: rgba(255, 255, 255, 0.4);
            font-family: 'Orbitron', sans-serif;
            font-size: 12px;
            letter-spacing: 2px;
            z-index: 5;
            pointer-events: none;
        }
        .footer-mark span { color: var(--neon-blue); }

    </style>
</head>
<body>

    <div class="horizon-glow"></div>
    <div class="cyber-grid"></div>
    <div id="stars-container"></div>
    <div class="scanlines"></div>

    <div id="stage"></div>

    <div class="footer-mark">DESIGNED BY <span>SUYU.2025</span></div>

    <script>
        // ================= 数据配置 (根据你的截图完全匹配) =================
        // pic 文件夹中的文件名需严格对应 id + .png
        const aiTools = [
            // 第一梯队：主流大模型
            { name: "ChatGPT", id: "gpt", url: "https://chat.openai.com", color: "#74aa9c", desc: "OpenAI 智能会话" },
            { name: "Gemini", id: "gemini", url: "https://gemini.google.com", color: "#4E86F5", desc: "Google 多模态 AI" },
            { name: "Claude", id: "claude", url: "https://claude.ai", color: "#d97757", desc: "Anthropic 高效模型" }, // 使用 claude.png
            { name: "DeepSeek", id: "deepseek", url: "https://www.deepseek.com", color: "#4b6bfb", desc: "深度求索 代码与推理" },
            
            // 第二梯队：搜索与社交
            { name: "Perplexity", id: "perplexity", url: "https://www.perplexity.ai", color: "#3c8b8b", desc: "AI 驱动的搜索引擎" },
            { name: "Grok", id: "grok", url: "https://grok.x.ai", color: "#ffffff", desc: "X 平台实时 AI" },
            { name: "Meta AI", id: "meta", url: "https://www.meta.ai", color: "#0668E1", desc: "Llama 3 开源模型" },
            { name: "Copilot", id: "microsoft", url: "https://copilot.microsoft.com", color: "#2E89F3", desc: "Microsoft 生产力助手" },
            
            // 第三梯队：多媒体与专业工具
            { name: "Midjourney", id: "midjourney", url: "https://www.midjourney.com", color: "#ffffff", desc: "艺术绘画生成" },
            { name: "Sora", id: "sora", url: "https://openai.com/sora", color: "#000000", desc: "视频生成模型" },
            { name: "Runway", id: "runway", url: "https://runwayml.com", color: "#c9fa4c", desc: "专业视频编辑 AI" },
            
            // 第四梯队：开源与国产
            { name: "HuggingFace", id: "huggingface", url: "https://huggingface.co", color: "#ffd21e", desc: "AI 模型开源社区" },
            { name: "Ollama", id: "ollama", url: "https://ollama.com", color: "#ffffff", desc: "本地运行大模型" },
            { name: "Qwen", id: "qwenr", url: "https://tongyi.aliyun.com", color: "#615ced", desc: "通义千问" }, // 注意文件名是 qwenr
            { name: "Ernie", id: "wenxin", url: "https://yiyan.baidu.com", color: "#0057ff", desc: "文心一言" }
        ];

        // ================= 引擎逻辑 =================
        const stage = document.getElementById('stage');
        const starsContainer = document.getElementById('stars-container');
        const orbs = [];
        let isTransitioning = false;

        // 1. 初始化星空 (粒子更多，有深浅)
        function initStars() {
            const count = 80;
            for (let i = 0; i < count; i++) {
                const star = document.createElement('div');
                star.className = 'star';
                const size = Math.random() * 3;
                star.style.width = `${size}px`;
                star.style.height = `${size}px`;
                star.style.left = `${Math.random() * 100}%`;
                star.style.top = `${Math.random() * 100}%`;
                star.style.opacity = Math.random();
                star.style.animationDuration = `${2 + Math.random() * 3}s`;
                starsContainer.appendChild(star);
            }
        }

        // 2. Orb 类
        class Orb {
            constructor(data, index) {
                this.data = data;
                
                // 尺寸适配
                const isMobile = window.innerWidth < 768;
                const baseSize = isMobile ? 80 : 130;
                // 略微随机大小
                this.realRadius = (baseSize * (0.9 + Math.random() * 0.2)) / 2;
                this.radius = this.realRadius; // 物理碰撞半径
                
                // 初始位置
                this.x = Math.random() * (window.innerWidth - this.realRadius * 2);
                this.y = Math.random() * (window.innerHeight - this.realRadius * 2);
                
                // 初始速度
                const v = isMobile ? 0.3 : 0.5;
                this.vx = (Math.random() - 0.5) * v;
                this.vy = (Math.random() - 0.5) * v;

                this.element = document.createElement('div');
                this.initDOM();
                
                // 状态标记
                this.isHovered = false;
                this.scale = 1; // 用于JS控制缩放
            }

            initDOM() {
                this.element.className = 'orb';
                this.element.style.width = `${this.realRadius * 2}px`;
                this.element.style.height = `${this.realRadius * 2}px`;
                this.element.style.setProperty('--glow-color', this.data.color);

                // 图片
                const img = document.createElement('img');
                // 修正：路径改为 pic/文件名.png
                img.src = `pic/${this.data.id}.png`;
                img.onerror = () => {
                    img.style.display = 'none';
                    const txt = document.createElement('div');
                    txt.className = 'orb-fallback-text';
                    txt.innerText = this.data.name[0];
                    this.element.appendChild(txt);
                };
                this.element.appendChild(img);

                // 悬浮信息
                const info = document.createElement('div');
                info.className = 'orb-info';
                info.innerHTML = `
                    <div class="orb-name">${this.data.name}</div>
                    <div class="orb-desc">${this.data.desc}</div>
                `;
                this.element.appendChild(info);

                // 事件监听
                this.element.addEventListener('mouseenter', () => this.onEnter());
                this.element.addEventListener('mouseleave', () => this.onLeave());
                this.element.addEventListener('click', () => this.onClick());
                // 移动端
                this.element.addEventListener('touchstart', (e) => {
                    // 阻止默认点击，手动处理
                    this.onEnter();
                }, {passive: true});

                stage.appendChild(this.element);
            }

            onEnter() {
                if (isTransitioning) return;
                this.isHovered = true;
                this.element.classList.add('hovered');
                this.scale = 1.2; // 目标缩放
            }

            onLeave() {
                if (isTransitioning) return;
                this.isHovered = false;
                this.element.classList.remove('hovered');
                this.scale = 1;
            }

            onClick() {
                if (isTransitioning) return;
                isTransitioning = true;

                // 自身动画
                this.element.classList.add('blackhole-active');
                
                // 其他球吸入动画
                orbs.forEach(o => {
                    if (o !== this) o.element.classList.add('sucked');
                });

                // 跳转
                setTimeout(() => {
                    window.open(this.data.url, '_blank');
                }, 800);

                // 自动复原 (3.5秒后)
                setTimeout(() => {
                    this.reset();
                }, 3500);
            }

            reset() {
                isTransitioning = false;
                this.element.classList.remove('blackhole-active');
                this.element.classList.remove('hovered');
                this.isHovered = false;
                this.scale = 1;
                
                orbs.forEach(o => {
                    o.element.classList.remove('sucked');
                });
            }

            update() {
                if (isTransitioning) return;

                // 1. 如果被鼠标悬停，强制停止运动（修复抖动BUG的核心）
                if (this.isHovered) {
                    this.vx = 0;
                    this.vy = 0;
                    // 位置不变，只做渲染
                } else {
                    // 正常物理运动
                    this.x += this.vx;
                    this.y += this.vy;

                    // 边界碰撞
                    if (this.x <= 0) { this.x = 0; this.vx *= -1; }
                    if (this.x + this.realRadius * 2 >= window.innerWidth) { 
                        this.x = window.innerWidth - this.realRadius * 2; 
                        this.vx *= -1; 
                    }
                    if (this.y <= 0) { this.y = 0; this.vy *= -1; }
                    if (this.y + this.realRadius * 2 >= window.innerHeight) { 
                        this.y = window.innerHeight - this.realRadius * 2; 
                        this.vy *= -1; 
                    }
                }

                // 2. 渲染 (使用 transform scale 来处理大小，不改变布局大小)
                // 这样碰撞检测依然基于原始大小，不会因为变大而卡住
                this.element.style.transform = `translate3d(${this.x}px, ${this.y}px, 0) scale(${this.scale})`;
            }
        }

        // 3. 物理循环
        function loop() {
            // A. 碰撞检测
            for (let i = 0; i < orbs.length; i++) {
                for (let j = i + 1; j < orbs.length; j++) {
                    const b1 = orbs[i];
                    const b2 = orbs[j];

                    const center1X = b1.x + b1.realRadius;
                    const center1Y = b1.y + b1.realRadius;
                    const center2X = b2.x + b2.realRadius;
                    const center2Y = b2.y + b2.realRadius;

                    const dx = center2X - center1X;
                    const dy = center2Y - center1Y;
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    const minDist = b1.realRadius + b2.realRadius;

                    if (dist < minDist) {
                        // 碰撞发生！
                        const angle = Math.atan2(dy, dx);
                        const overlap = minDist - dist + 1; // +1防止粘连

                        // 分离向量
                        const moveX = (overlap / 2) * Math.cos(angle);
                        const moveY = (overlap / 2) * Math.sin(angle);

                        // 关键修复：如果有球被悬停，它就是“墙”，不移动
                        if (b1.isHovered && !b2.isHovered) {
                            b2.x += moveX * 2; b2.y += moveY * 2;
                            b2.vx = Math.abs(b2.vx) * Math.cos(angle) * 2; // 被弹开
                            b2.vy = Math.abs(b2.vy) * Math.sin(angle) * 2;
                        } 
                        else if (!b1.isHovered && b2.isHovered) {
                            b1.x -= moveX * 2; b1.y -= moveY * 2;
                            b1.vx = -Math.abs(b1.vx) * Math.cos(angle) * 2;
                            b1.vy = -Math.abs(b1.vy) * Math.sin(angle) * 2;
                        } 
                        else if (!b1.isHovered && !b2.isHovered) {
                            // 正常碰撞
                            b1.x -= moveX; b1.y -= moveY;
                            b2.x += moveX; b2.y += moveY;
                            
                            // 简单的速度交换
                            const tempVx = b1.vx; const tempVy = b1.vy;
                            b1.vx = b2.vx; b1.vy = b2.vy;
                            b2.vx = tempVx; b2.vy = tempVy;
                        }
                    }
                }
            }

            // B. 更新状态
            orbs.forEach(o => o.update());
            requestAnimationFrame(loop);
        }

        // 初始化
        initStars();
        aiTools.forEach((data, i) => {
            orbs.push(new Orb(data, i));
        });
        loop();

        // 窗口调整
        window.addEventListener('resize', () => {
             // 简单的复位防止跑出去
             orbs.forEach(o => {
                 o.x = Math.min(o.x, window.innerWidth - o.realRadius*2);
                 o.y = Math.min(o.y, window.innerHeight - o.realRadius*2);
             })
        });

    </script>
</body>
</html>
