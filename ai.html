<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>AI NEXUS: Liquid Future</title>
    <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@500;700&family=Rajdhani:wght@400;600&display=swap" rel="stylesheet">
    <style>
        :root {
            /* 极致深黑背景 */
            --bg-deep: #000000; 
            /* 极微弱的星云色，几乎不可见，只在光照下显现 */
            --nebula-1: rgba(20, 20, 30, 0.4); 
            --nebula-2: rgba(10, 10, 15, 0.2); 
            --accent-color: #00f3ff;
        }

        * {
            margin: 0; padding: 0; box-sizing: border-box;
            user-select: none; -webkit-tap-highlight-color: transparent;
        }

        body {
            width: 100vw; height: 100vh;
            background-color: var(--bg-deep);
            overflow: hidden;
            font-family: 'Rajdhani', sans-serif;
            position: relative;
            /* 极简深空渐变：中心微亮，四周纯黑 */
            background-image: radial-gradient(circle at center, #0a0a12 0%, #000000 80%);
        }

        /* --- 背景层：幽暗星云 (调整得更隐秘) --- */
        .nebula-container {
            position: absolute; width: 100%; height: 100%;
            filter: blur(80px); 
            z-index: 0; 
            opacity: 0.6; 
            will-change: transform;
            pointer-events: none;
        }

        .nebula-layer {
            position: absolute; top: -50%; left: -50%; width: 200%; height: 200%;
            background-size: 100% 100%;
            animation-timing-function: linear;
            animation-iteration-count: infinite;
        }

        .nl-1 {
            background: radial-gradient(ellipse at 40% 40%, var(--nebula-1) 0%, transparent 50%);
            animation: nebulaSpin 150s infinite;
        }
        .nl-2 {
            background: radial-gradient(ellipse at 60% 60%, var(--nebula-2) 0%, transparent 50%);
            animation: nebulaSpin 200s reverse infinite;
        }

        @keyframes nebulaSpin { from { transform: rotate(0deg); } to { transform: rotate(360deg); } }

        /* 星星 */
        #stars-container {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 1; pointer-events: none;
        }
        .star {
            position: absolute; background: white; border-radius: 50%;
            opacity: 0.8; animation: twinkle infinite alternate;
        }
        @keyframes twinkle { 0% { opacity: 0.3; } 100% { opacity: 1; } }

        /* 舞台 */
        #stage {
            position: relative; width: 100%; height: 100%; z-index: 10;
        }

        /* --- 核心：Liquid Glass (液态玻璃) 样式 --- */
        .orb {
            position: absolute;
            border-radius: 50%;
            /* 1. 基础通透感 */
            background: rgba(255, 255, 255, 0.01); 
            /* 2. 混合模式增加亮度 */
            backdrop-filter: blur(8px) saturate(120%); 
            -webkit-backdrop-filter: blur(8px) saturate(120%);
            
            /* 3. 液态光影层：多重内阴影模拟厚度 */
            box-shadow: 
                inset 0 0 15px rgba(255, 255, 255, 0.05), /* 整体微光 */
                inset 2px 4px 10px rgba(255, 255, 255, 0.2), /* 左上高光边缘 */
                inset -2px -4px 15px rgba(0, 0, 0, 0.6), /* 右下深邃厚度 */
                0 0 20px var(--glow-color-dim); /* 外部辉光 (在JS里设置变量) */

            border: 1px solid rgba(255, 255, 255, 0.15); /* 极细的外框 */
            border-top: 1px solid rgba(255, 255, 255, 0.4); /* 顶部更亮，模拟光源 */
            border-bottom: 1px solid rgba(255, 255, 255, 0.05);

            display: flex; flex-direction: column; justify-content: center; align-items: center;
            cursor: pointer;
            
            /* 物理引擎控制位置，这里只过渡视觉属性 */
            transition: box-shadow 0.4s ease, border-color 0.4s ease, filter 0.4s ease;
            will-change: transform;
        }

        /* 液态高光 (Specular Highlight) */
        .orb::after {
            content: ''; position: absolute;
            top: 5%; left: 12%; width: 50%; height: 30%;
            border-radius: 50%;
            background: radial-gradient(ellipse at center, rgba(255,255,255,0.9) 0%, rgba(255,255,255,0) 60%);
            transform: rotate(-45deg); opacity: 0.6; filter: blur(1px);
            pointer-events: none;
        }
        
        /* 底部反光 (Rim Light) */
        .orb::before {
            content: ''; position: absolute;
            bottom: 5%; right: 10%; width: 60%; height: 30%;
            border-radius: 50%;
            background: radial-gradient(ellipse at center, var(--glow-color), transparent 70%);
            transform: rotate(-45deg); opacity: 0.3; filter: blur(5px);
            pointer-events: none;
        }

        .orb img {
            width: 55%; height: 55%;
            object-fit: contain; pointer-events: none; z-index: 2;
            /* Logo 也有轻微的玻璃投影 */
            filter: drop-shadow(0 4px 8px rgba(0,0,0,0.3));
            transition: opacity 0.2s, transform 0.3s;
        }

        /* 悬浮信息 */
        .orb-info {
            position: absolute; bottom: -60px; left: 50%; transform: translateX(-50%);
            width: 200px; text-align: center; opacity: 0; pointer-events: none;
            transition: opacity 0.3s; z-index: 20;
            /* 磨砂黑底 */
            background: rgba(10, 10, 10, 0.8); backdrop-filter: blur(10px);
            border: 1px solid rgba(255,255,255,0.2); border-radius: 8px;
            padding: 6px 10px;
        }
        .orb-name { font-family: 'Orbitron', sans-serif; font-size: 14px; color: #fff; letter-spacing: 1px; }
        .orb-desc { font-size: 10px; color: #aaa; }

        /* --- 交互状态 --- */
        
        /* 悬停：液态感增强 */
        .orb.hovered {
            z-index: 1000 !important;
            border-color: rgba(255,255,255,0.8);
            box-shadow: 
                inset 0 0 20px rgba(255, 255, 255, 0.2),
                0 0 50px var(--glow-color); /* 强烈的外发光 */
        }
        .orb.hovered img { transform: scale(1.1); }
        .orb.hovered .orb-info { opacity: 1; bottom: -70px; }

        /* 黑洞特效 */
        .orb.blackhole-active { z-index: 9999 !important; animation: blackhole 0.8s cubic-bezier(0.7,0,0.2,1) forwards; }
        @keyframes blackhole {
            0% { transform: scale(1.2); filter: brightness(1.5); }
            40% { transform: scale(0.1); filter: brightness(50); background: #fff; } /* 坍缩成奇点 */
            100% { transform: scale(0); opacity: 0; }
        }
        .orb.sucked { transition: transform 0.6s ease, opacity 0.6s; transform: scale(0.3) !important; opacity: 0; }

        /* --- UI控件：归位按钮 --- */
        .control-btn {
            position: absolute; bottom: 20px; left: 20px;
            width: 44px; height: 44px;
            border-radius: 12px;
            background: rgba(255, 255, 255, 0.05);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            display: flex; justify-content: center; align-items: center;
            cursor: pointer; z-index: 100;
            transition: all 0.3s ease;
            color: rgba(255,255,255,0.6);
        }
        .control-btn:hover {
            background: rgba(255, 255, 255, 0.15);
            border-color: rgba(255, 255, 255, 0.4);
            color: #fff;
            transform: scale(1.05);
            box-shadow: 0 0 15px rgba(255,255,255,0.1);
        }
        .control-btn svg { width: 20px; height: 20px; fill: currentColor; }

        .footer-mark {
            position: absolute; bottom: 20px; right: 20px;
            color: rgba(255, 255, 255, 0.2); font-family: 'Orbitron', sans-serif;
            font-size: 10px; letter-spacing: 2px; z-index: 5; pointer-events: none;
        }

    </style>
</head>
<body>

    <div class="nebula-container">
        <div class="nebula-layer nl-1"></div>
        <div class="nebula-layer nl-2"></div>
    </div>
    <div id="stars-container"></div>

    <div id="stage"></div>

    <div class="control-btn" id="dock-btn" title="矩阵归位 / 自由漂浮">
        <svg viewBox="0 0 24 24"><path d="M4 4h4v4H4zm6 0h4v4h-4zm6 0h4v4h-4zM4 10h4v4H4zm6 0h4v4h-4zm6 0h4v4h-4zM4 16h4v4H4zm6 0h4v4h-4zm6 0h4v4h-4z"/></svg>
    </div>

    <div class="footer-mark">SUYU.2025</div>

    <script>
        // ================= 数据 =================
        const aiTools = [
            { name: "ChatGPT", id: "gpt", url: "https://chat.openai.com", color: "#10a37f", desc: "OpenAI 智能助手" },
            { name: "Gemini", id: "gemini", url: "https://gemini.google.com", color: "#4E86F5", desc: "Google 多模态 AI" },
            { name: "Claude", id: "claude", url: "https://claude.ai", color: "#d97757", desc: "Anthropic 长文本" },
            { name: "DeepSeek", id: "deepseek", url: "https://www.deepseek.com", color: "#4b6bfb", desc: "深度求索" },
            { name: "Perplexity", id: "perplexity", url: "https://www.perplexity.ai", color: "#24bba1", desc: "AI 搜索" },
            { name: "Grok", id: "grok", url: "https://grok.x.ai", color: "#ffffff", desc: "X 平台实时 AI" },
            { name: "Meta AI", id: "meta", url: "https://www.meta.ai", color: "#0064e0", desc: "Llama 生态" },
            { name: "Copilot", id: "microsoft", url: "https://copilot.microsoft.com", color: "#2E89F3", desc: "Microsoft 助手" },
            { name: "Midjourney", id: "midjourney", url: "https://www.midjourney.com", color: "#ffffff", desc: "AI 绘画" },
            { name: "Sora", id: "sora", url: "https://openai.com/sora", color: "#ff3366", desc: "视频生成" },
            { name: "Runway", id: "runway", url: "https://runwayml.com", color: "#c9fa4c", desc: "视频编辑" },
            { name: "HuggingFace", id: "huggingface", url: "https://huggingface.co", color: "#ffd21e", desc: "开源社区" },
            { name: "Ollama", id: "ollama", url: "https://ollama.com", color: "#ffffff", desc: "本地运行" },
            { name: "Qwen", id: "qwenr", url: "https://tongyi.aliyun.com", color: "#615ced", desc: "通义千问" },
            { name: "Ernie", id: "wenxin", url: "https://yiyan.baidu.com", color: "#0057ff", desc: "文心一言" }
        ];

        // ================= 引擎核心 =================
        const stage = document.getElementById('stage');
        const starsContainer = document.getElementById('stars-container');
        const dockBtn = document.getElementById('dock-btn');
        const orbs = [];
        
        let isTransitioning = false; // 页面跳转动画锁
        let isDocked = false; // 是否处于归位状态
        let animationId;

        // 星星初始化
        function initStars() {
            const count = 100;
            for (let i = 0; i < count; i++) {
                const s = document.createElement('div');
                s.className = 'star';
                const size = Math.random() * 2;
                s.style.width = size + 'px'; s.style.height = size + 'px';
                s.style.left = Math.random() * 100 + '%'; s.style.top = Math.random() * 100 + '%';
                s.style.animationDuration = (2 + Math.random() * 3) + 's';
                starsContainer.appendChild(s);
            }
        }

        class Orb {
            constructor(data, index) {
                this.data = data;
                this.index = index;
                
                // 尺寸设定
                const isMobile = window.innerWidth < 768;
                const baseSize = isMobile ? 80 : 120;
                this.realRadius = (baseSize * (0.9 + Math.random() * 0.2)) / 2;
                this.radius = this.realRadius; 
                
                // 随机位置
                this.x = Math.random() * (window.innerWidth - this.realRadius * 2);
                this.y = Math.random() * (window.innerHeight - this.realRadius * 2);
                
                // 随机速度
                const v = 0.5;
                this.vx = (Math.random() - 0.5) * v;
                this.vy = (Math.random() - 0.5) * v;

                // 归位目标坐标
                this.targetX = 0;
                this.targetY = 0;

                this.element = null;
                this.imgElement = null;
                this.isHovered = false;
                this.scale = 1;
                this.hoverTimer = null;
                
                this.initDOM();
            }

            initDOM() {
                this.element = document.createElement('div');
                this.element.className = 'orb';
                this.element.style.width = this.realRadius * 2 + 'px';
                this.element.style.height = this.realRadius * 2 + 'px';
                
                // 设置光晕变量，用于CSS
                this.element.style.setProperty('--glow-color', this.data.color);
                // 设置一个暗一点的颜色用于常态
                this.element.style.setProperty('--glow-color-dim', this.data.color + '40'); // 40 is hex opacity

                this.imgElement = document.createElement('img');
                this.imgElement.src = `pic/${this.data.id}.png`;
                this.imgElement.onerror = () => {
                    this.imgElement.style.display = 'none';
                    const t = document.createElement('div');
                    t.innerText = this.data.name[0];
                    t.style.fontSize = '2em'; t.style.color = 'rgba(255,255,255,0.5)'; t.style.fontWeight = 'bold';
                    this.element.appendChild(t);
                };
                this.element.appendChild(this.imgElement);

                const info = document.createElement('div');
                info.className = 'orb-info';
                info.innerHTML = `<div class="orb-name">${this.data.name}</div><div class="orb-desc">${this.data.desc}</div>`;
                this.element.appendChild(info);

                // 事件
                this.element.addEventListener('mouseenter', () => this.onEnter());
                this.element.addEventListener('mouseleave', () => this.onLeave());
                this.element.addEventListener('touchstart', () => this.onEnter(), {passive: true});
                this.element.addEventListener('click', () => this.onClick());

                stage.appendChild(this.element);
            }

            onEnter() {
                if (isTransitioning) return;
                this.isHovered = true;
                this.element.classList.add('hovered');
                this.scale = 1.15;
                
                // 仅在非归位模式下启用冲击波，防止破坏矩阵
                if (!isDocked) {
                    if (this.hoverTimer) clearTimeout(this.hoverTimer);
                    this.hoverTimer = setTimeout(() => this.triggerShockwave(), 3000);
                }
            }

            onLeave() {
                if (isTransitioning) return;
                this.isHovered = false;
                this.element.classList.remove('hovered');
                this.scale = 1;
                if (this.hoverTimer) clearTimeout(this.hoverTimer);
            }

            triggerShockwave() {
                if (!this.isHovered || isTransitioning || isDocked) return;
                const force = 12;
                orbs.forEach(t => {
                    if (t === this) return;
                    const dx = (t.x + t.realRadius) - (this.x + this.realRadius);
                    const dy = (t.y + t.realRadius) - (this.y + this.realRadius);
                    const dist = Math.sqrt(dx*dx + dy*dy);
                    if (dist > 0) {
                        t.vx += (dx/dist) * force;
                        t.vy += (dy/dist) * force;
                    }
                });
            }

            onClick() {
                if (isTransitioning) return;
                isTransitioning = true;
                if (this.hoverTimer) clearTimeout(this.hoverTimer);

                // 锁定位置
                this.element.style.left = this.x + 'px';
                this.element.style.top = this.y + 'px';
                this.element.style.transform = 'none';

                this.element.classList.add('blackhole-active');
                orbs.forEach(o => { if (o !== this) o.element.classList.add('sucked'); });

                setTimeout(() => window.open(this.data.url, '_blank'), 800);
                setTimeout(() => this.reset(), 3000);
            }

            reset() {
                isTransitioning = false;
                orbs.forEach(o => {
                    if (o.hoverTimer) clearTimeout(o.hoverTimer);
                    o.element.classList.remove('blackhole-active', 'sucked', 'hovered');
                    o.isHovered = false;
                    o.scale = 1;
                    if(o.imgElement) o.imgElement.style.opacity = '';
                    o.element.style.left = ''; o.element.style.top = '';
                    o.updateRenderer();
                });
            }

            // 计算归位模式下的移动 (Lerp)
            updateDocking() {
                // 平滑移动系数
                const easing = 0.05; 
                this.x += (this.targetX - this.x) * easing;
                this.y += (this.targetY - this.y) * easing;
                
                // 归位模式下，速度归零，防止切回物理模式时乱飞
                this.vx = 0; this.vy = 0;
            }

            // 物理模式
            updatePhysics() {
                if (this.isHovered) return; // 悬停不动
                this.x += this.vx;
                this.y += this.vy;

                // 简单的边界
                if (this.x <= 0) { this.x = 0; this.vx *= -1; }
                if (this.x + this.realRadius*2 >= window.innerWidth) { this.x = window.innerWidth - this.realRadius*2; this.vx *= -1; }
                if (this.y <= 0) { this.y = 0; this.vy *= -1; }
                if (this.y + this.realRadius*2 >= window.innerHeight) { this.y = window.innerHeight - this.realRadius*2; this.vy *= -1; }
            }

            updateRenderer() {
                if (isTransitioning) return;
                this.element.style.transform = `translate3d(${this.x}px, ${this.y}px, 0) scale(${this.scale})`;
            }
        }

        // ================= 归位计算逻辑 =================
        function calculateDockPositions() {
            const isMobile = window.innerWidth < 768;
            const cols = isMobile ? 4 : 8; // 每行个数
            const gap = 10; // 间隙
            const margin = 20; 
            const bottomAreaHeight = isMobile ? 300 : 250; // 底部预留高度
            
            // 基础网格大小
            const cellW = (window.innerWidth - margin * 2) / cols;
            // 垂直起始点
            const startY = window.innerHeight - bottomAreaHeight;

            orbs.forEach((orb, i) => {
                const col = i % cols;
                const row = Math.floor(i / cols);
                
                // 目标 X: 居中对齐
                const centerX = margin + col * cellW + cellW/2;
                orb.targetX = centerX - orb.realRadius;
                
                // 目标 Y: 从下往上排，还是从上往下？这里从设定线开始往下排
                const centerY = startY + row * (orb.realRadius * 2 + gap * 2) + orb.realRadius;
                orb.targetY = centerY - orb.realRadius;
            });
        }

        dockBtn.addEventListener('click', () => {
            isDocked = !isDocked;
            dockBtn.style.opacity = isDocked ? '1' : '0.6';
            
            if (isDocked) {
                calculateDockPositions();
            } else {
                // 散开：给每个球一个随机微小速度，重新激活物理
                orbs.forEach(o => {
                    o.vx = (Math.random() - 0.5) * 2;
                    o.vy = (Math.random() - 0.5) * 2;
                });
            }
        });

        window.addEventListener('resize', () => {
            if (isDocked) calculateDockPositions();
        });


        // ================= 主循环 =================
        function loop() {
            if (!isTransitioning) {
                
                if (isDocked) {
                    // 模式 A: 归位模式 (无碰撞，平滑移动)
                    orbs.forEach(o => o.updateDocking());
                } else {
                    // 模式 B: 物理漂浮模式 (有碰撞)
                    
                    // 1. 碰撞检测
                    for (let i = 0; i < orbs.length; i++) {
                        for (let j = i + 1; j < orbs.length; j++) {
                            const b1 = orbs[i]; const b2 = orbs[j];
                            const dx = (b2.x + b2.realRadius) - (b1.x + b1.realRadius);
                            const dy = (b2.y + b2.realRadius) - (b1.y + b1.realRadius);
                            const dist = Math.sqrt(dx*dx + dy*dy);
                            const minDist = b1.realRadius + b2.realRadius;

                            if (dist < minDist) {
                                const angle = Math.atan2(dy, dx);
                                const overlap = minDist - dist + 0.5;
                                const moveX = (overlap/2) * Math.cos(angle);
                                const moveY = (overlap/2) * Math.sin(angle);

                                if (b1.isHovered && !b2.isHovered) {
                                    b2.x += moveX*2; b2.y += moveY*2;
                                    b2.vx = Math.abs(b2.vx)*Math.cos(angle)*1.5; b2.vy = Math.abs(b2.vy)*Math.sin(angle)*1.5;
                                } else if (!b1.isHovered && b2.isHovered) {
                                    b1.x -= moveX*2; b1.y -= moveY*2;
                                    b1.vx = -Math.abs(b1.vx)*Math.cos(angle)*1.5; b1.vy = -Math.abs(b1.vy)*Math.sin(angle)*1.5;
                                } else if (!b1.isHovered && !b2.isHovered) {
                                    b1.x -= moveX; b1.y -= moveY; b2.x += moveX; b2.y += moveY;
                                    const tvx = b1.vx; const tvy = b1.vy; b1.vx = b2.vx; b1.vy = b2.vy; b2.vx = tvx; b2.vy = tvy;
                                }
                            }
                        }
                    }
                    
                    // 2. 物理运动
                    orbs.forEach(o => o.updatePhysics());
                }
            }

            // 渲染
            orbs.forEach(o => o.updateRenderer());
            requestAnimationFrame(loop);
        }

        // 启动
        initStars();
        aiTools.forEach((d, i) => orbs.push(new Orb(d, i)));
        loop();

    </script>
</body>
</html>
