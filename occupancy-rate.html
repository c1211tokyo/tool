<!DOCTYPE html>
<html lang="zh">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>æ™ºèƒ½å…¥ä½ç‡åˆ†æç³»ç»Ÿ (OCRç‰ˆ)</title>
<script src="https://cdn.jsdelivr.net/npm/echarts/dist/echarts.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/xlsx@0.18.5/dist/xlsx.full.min.js"></script>
<script src='https://cdn.jsdelivr.net/npm/tesseract.js@4/dist/tesseract.min.js'></script>

<style>
    :root { --primary: #0071e3; --bg: #f5f5f7; --card: #fff; --border: #d2d2d7; }
    body { font-family: -apple-system, sans-serif; background: var(--bg); color: #1d1d1f; margin: 0; padding: 20px; }
    .container { max-width: 1280px; margin: 0 auto; }
    
    /* é¡¶éƒ¨ä¸å¡ç‰‡ */
    header { text-align: center; margin-bottom: 20px; }
    h1 { margin: 0; font-size: 24px; font-weight: 600; }
    .card { background: var(--card); border-radius: 12px; padding: 20px; box-shadow: 0 4px 12px rgba(0,0,0,0.05); margin-bottom: 20px; }
    
    /* æ§åˆ¶åŒº */
    .controls { display: flex; gap: 15px; flex-wrap: wrap; align-items: center; background: #f9f9f9; padding: 15px; border-radius: 8px; }
    .control-group { display: flex; flex-direction: column; gap: 4px; }
    .control-group label { font-size: 12px; color: #666; font-weight: 500; }
    input[type="number"], input[type="date"] { padding: 6px; border: 1px solid var(--border); border-radius: 6px; width: 100px; }
    
    .btn { background: var(--primary); color: white; border: none; padding: 8px 18px; border-radius: 6px; font-size: 13px; cursor: pointer; transition: 0.2s; display: flex; align-items: center; gap: 6px; }
    .btn:hover { background: #0077ed; }
    .btn:disabled { background: #ccc; cursor: not-allowed; }
    .btn-danger { background: #ff3b30; padding: 2px 6px; font-size: 11px; margin-left: 4px; border-radius: 4px; }

    /* ç”»å¸ƒ */
    .canvas-container { position: relative; overflow: auto; text-align: center; background: #333; border-radius: 8px; padding: 10px; max-height: 80vh; }
    canvas { max-width: 100%; box-shadow: 0 0 10px rgba(0,0,0,0.3); }

    /* ç»“æœåŒº */
    .tabs { display: flex; gap: 10px; border-bottom: 1px solid var(--border); padding-bottom: 10px; margin-bottom: 15px; }
    .tab { padding: 6px 16px; border-radius: 20px; cursor: pointer; font-size: 13px; background: #f0f0f0; color: #666; }
    .tab.active { background: var(--primary); color: white; }

    /* è¡¨æ ¼ */
    .table-wrap { overflow-x: auto; }
    table { width: 100%; border-collapse: collapse; font-size: 12px; white-space: nowrap; }
    th, td { border: 1px solid #e5e5e5; padding: 6px 4px; text-align: center; }
    th { background: #f2f2f7; font-weight: 600; position: sticky; top: 0; z-index: 10; }
    
    /* çŠ¶æ€ä¸åŠ è½½ */
    .occupied { background-color: rgba(52, 199, 89, 0.25) !important; } /* ç»¿è‰²èƒŒæ™¯ */
    .loading-overlay { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(255,255,255,0.9); z-index: 999; display: none; flex-direction: column; justify-content: center; align-items: center; }
    .spinner { width: 40px; height: 40px; border: 4px solid #f3f3f3; border-top: 4px solid var(--primary); border-radius: 50%; animation: spin 1s linear infinite; }
    @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }

    /* æç¤ºä¿¡æ¯ */
    .tip { font-size: 12px; color: #86868b; margin-top: 5px; background: #fffbe6; border: 1px solid #ffe58f; padding: 8px; border-radius: 4px; }
    
    /* æˆ¿åè¾“å…¥æ¡† */
    .th-input { border: none; background: transparent; font-weight: bold; width: 80px; text-align: center; font-size: 12px; }
    .th-input:focus { outline: 2px solid var(--primary); background: #fff; }
</style>
</head>
<body>

<div class="loading-overlay" id="loading">
    <div class="spinner"></div>
    <p id="loadingText" style="margin-top:15px; font-weight:500;">æ­£åœ¨åŠ è½½ OCR å¼•æ“...</p>
</div>

<div class="container">
    <header>
        <h1>æ™ºèƒ½å…¥ä½ç‡åˆ†æç³»ç»Ÿ <span style="font-size:14px; color:#fff; background:#ff9500; padding:2px 6px; border-radius:4px; vertical-align:middle;">OCRå¢å¼ºç‰ˆ</span></h1>
    </header>

    <div class="card">
        <div class="controls">
            <div class="control-group">
                <label>1. ä¸Šä¼ å›¾ç‰‡</label>
                <input type="file" id="imgInput" accept="image/*">
            </div>
            <div class="control-group">
                <label>2. æˆ¿é—´æ•° (åˆ—)</label>
                <input type="number" id="colCount" value="15" min="1">
            </div>
            <div class="control-group">
                <label>3. ç»Ÿè®¡å¤©æ•° (è¡Œ)</label>
                <input type="number" id="rowCount" value="30" min="1">
            </div>
            <div class="control-group">
                <label>4. èµ·å§‹æ—¥æœŸ</label>
                <input type="date" id="startDate">
            </div>
            <div style="flex-grow:1; text-align:right;">
                <button class="btn" onclick="runAnalysis()">
                    <svg width="16" height="16" fill="none" stroke="currentColor" stroke-width="2" viewBox="0 0 24 24"><path d="M13 10V3L4 14h7v7l9-11h-7z"></path></svg>
                    å¼€å§‹åˆ†æ & è¯†åˆ«æˆ¿å
                </button>
            </div>
        </div>
        
        <div class="tip">
            <strong>æ“ä½œæŒ‡å—ï¼š</strong>
            1. ä¸Šä¼ å›¾ç‰‡åï¼Œæ‹–åŠ¨çº¢æ¡†è¦†ç›–<b>çº¯æ ¼å­åŒºåŸŸ</b>ï¼ˆä¸å«è¡¨å¤´æ–‡å­—ï¼‰ã€‚
            2. è°ƒæ•´â€œæˆ¿é—´æ•°â€ç›´åˆ°çº¢è‰²ç«–çº¿ä¸å›¾ç‰‡ä¸­çš„åˆ—çº¿å®Œå…¨é‡åˆï¼ˆåŒ…å«ç©ºç™½åˆ—ï¼‰ã€‚
            3. ç³»ç»Ÿä¼šè‡ªåŠ¨å‘ä¸Šæ‰«æè¯†åˆ«æˆ¿åã€‚å¦‚æœä¸­é—´æœ‰ç©ºç™½åˆ†éš”åˆ—ï¼Œç»“æœç”Ÿæˆåç‚¹å‡»è¡¨å¤´çš„åˆ é™¤æŒ‰é’®å³å¯ã€‚
        </div>

        <div class="canvas-container">
            <canvas id="mainCanvas"></canvas>
        </div>
    </div>

    <div class="card" id="resultCard" style="display:none;">
        <div class="tabs">
            <div class="tab active" onclick="switchTab('table')">ğŸ“Š æ•°æ®è¡¨æ ¼ (å¯ä¿®æ­£)</div>
            <div class="tab" onclick="switchTab('chart')">ğŸ“ˆ ç»Ÿè®¡å›¾è¡¨</div>
            <button class="btn" style="margin-left:auto; background:#34c759;" onclick="exportExcel()">ğŸ“¥ å¯¼å‡º Excel</button>
        </div>

        <div style="display:flex; gap:20px; margin-bottom:15px; padding:10px; background:#f5f7fa; border-radius:8px; font-size:13px;">
            <div>æ€»æˆ¿æ™š: <strong id="valTotalSlots">-</strong></div>
            <div>å…¥ä½: <strong id="valOccupied" style="color:#34c759">-</strong></div>
            <div>æ€»å…¥ä½ç‡: <strong id="valRate" style="color:#0071e3">-</strong></div>
        </div>

        <div id="viewTable" class="table-wrap">
            <table id="dataTable"></table>
        </div>

        <div id="viewChart" style="display:none;">
            <div id="chartMain" style="width: 100%; height: 450px;"></div>
        </div>
    </div>
</div>

<script>
// --- å…¨å±€å˜é‡ ---
let img = new Image();
let canvas = document.getElementById('mainCanvas');
let ctx = canvas.getContext('2d');
// ç½‘æ ¼çŠ¶æ€
let grid = { x: 50, y: 100, w: 0, h: 0 }; 
let isDragging = false;
let dragHandle = null;
// æ•°æ®çŠ¶æ€
let rawData = []; // 0/1 çŸ©é˜µ
let roomNames = []; 
let dateList = [];
let validCols = []; // å­˜å‚¨å½“å‰æœ‰æ•ˆçš„åˆ—ç´¢å¼•ï¼ˆç”¨äºåˆ é™¤åˆ—åŠŸèƒ½ï¼‰

// åˆå§‹åŒ–æ—¥æœŸ
document.getElementById('startDate').valueAsDate = new Date();

// --- 1. å›¾ç‰‡å¤„ç† ---
document.getElementById('imgInput').addEventListener('change', function(e) {
    if(!e.target.files[0]) return;
    const reader = new FileReader();
    reader.onload = function(evt) {
        img.onload = function() { initCanvas(); }
        img.src = evt.target.result;
    }
    reader.readAsDataURL(e.target.files[0]);
});

function initCanvas() {
    // é«˜æ¸…å±é€‚é…ï¼Œä½†ä¿æŒé€»è¾‘å°ºå¯¸å¯æ§
    const maxWidth = 1200;
    const scale = Math.min(1, maxWidth / img.width);
    canvas.width = img.width * scale;
    canvas.height = img.height * scale;
    
    // é»˜è®¤ç½‘æ ¼ä½ç½®ï¼šç•™å‡ºé¡¶éƒ¨ç©ºé—´ç»™OCRè¯†åˆ«
    grid.x = canvas.width * 0.05;
    grid.y = canvas.height * 0.15; // å¾€ä¸‹ä¸€ç‚¹ï¼Œç»™è¡¨å¤´ç•™ä½ç½®
    grid.w = canvas.width * 0.9;
    grid.h = canvas.height * 0.8;

    draw();
}

// --- 2. äº¤äº’å¼ç»˜å›¾ç³»ç»Ÿ ---
function draw() {
    if (!ctx) return;
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    ctx.drawImage(img, 0, 0, canvas.width, canvas.height);

    // é®ç½©å±‚
    ctx.fillStyle = 'rgba(0,0,0,0.4)';
    ctx.fillRect(0,0,canvas.width, grid.y);
    ctx.fillRect(0,grid.y+grid.h,canvas.width, canvas.height-(grid.y+grid.h));
    ctx.fillRect(0,grid.y,grid.x,grid.h);
    ctx.fillRect(grid.x+grid.w, grid.y, canvas.width-(grid.x+grid.w), grid.h);

    // ä¸»ç½‘æ ¼
    ctx.strokeStyle = '#ff3b30';
    ctx.lineWidth = 2;
    ctx.strokeRect(grid.x, grid.y, grid.w, grid.h);

    // OCR æ‰«æåŒºåŸŸé¢„ç¤º (ä¸Šæ–¹é»„è‰²è™šçº¿æ¡†)
    ctx.save();
    ctx.strokeStyle = '#ffcc00';
    ctx.lineWidth = 2;
    ctx.setLineDash([5, 5]);
    // å‡è®¾è¡¨å¤´é«˜åº¦å¤§çº¦æ˜¯ grid é«˜åº¦çš„ 1/rows * 2 (ä¸¤è¡Œé«˜) æˆ–è€…å›ºå®šåƒç´ 
    const headerHeight = Math.min(grid.y, 80); 
    ctx.strokeRect(grid.x, grid.y - headerHeight, grid.w, headerHeight);
    ctx.fillStyle = 'rgba(255, 204, 0, 0.2)';
    ctx.fillRect(grid.x, grid.y - headerHeight, grid.w, headerHeight);
    ctx.restore();

    // ç»˜åˆ¶å†…éƒ¨åˆ†å‰²çº¿
    const cols = parseInt(document.getElementById('colCount').value) || 1;
    const rows = parseInt(document.getElementById('rowCount').value) || 1;
    
    ctx.beginPath();
    ctx.strokeStyle = 'rgba(255, 59, 48, 0.5)';
    ctx.lineWidth = 1;

    // ç«–çº¿
    const cellW = grid.w / cols;
    for(let i=1; i<cols; i++) {
        let x = grid.x + i * cellW;
        ctx.moveTo(x, grid.y);
        ctx.lineTo(x, grid.y + grid.h);
    }
    // æ¨ªçº¿
    const cellH = grid.h / rows;
    for(let i=1; i<rows; i++) {
        let y = grid.y + i * cellH;
        ctx.moveTo(grid.x, y);
        ctx.lineTo(grid.x + grid.w, y);
    }
    ctx.stroke();

    // æ‹–æ‹½æ‰‹æŸ„
    drawHandle(grid.x, grid.y);
    drawHandle(grid.x+grid.w, grid.y+grid.h);
}

function drawHandle(x, y) {
    ctx.beginPath();
    ctx.arc(x, y, 8, 0, Math.PI*2);
    ctx.fillStyle = '#fff';
    ctx.fill();
    ctx.strokeStyle = '#0071e3';
    ctx.stroke();
}

// æ‹–æ‹½é€»è¾‘
canvas.addEventListener('mousedown', e => {
    const rect = canvas.getBoundingClientRect();
    const x = (e.clientX - rect.left) * (canvas.width / rect.width); // åæ ‡æ˜ å°„
    const y = (e.clientY - rect.top) * (canvas.height / rect.height);
    
    if(dist(x,y, grid.x, grid.y) < 20) dragHandle = 'tl';
    else if(dist(x,y, grid.x+grid.w, grid.y+grid.h) < 20) dragHandle = 'br';
    else if(x>grid.x && x<grid.x+grid.w && y>grid.y && y<grid.y+grid.h) {
        dragHandle = 'move';
        canvas.lastX = x; canvas.lastY = y;
    }
    if(dragHandle) isDragging = true;
});

canvas.addEventListener('mousemove', e => {
    if(!isDragging) return;
    const rect = canvas.getBoundingClientRect();
    const x = (e.clientX - rect.left) * (canvas.width / rect.width);
    const y = (e.clientY - rect.top) * (canvas.height / rect.height);

    if(dragHandle === 'move') {
        grid.x += x - canvas.lastX;
        grid.y += y - canvas.lastY;
        canvas.lastX = x; canvas.lastY = y;
    } else if(dragHandle === 'tl') {
        let oldR = grid.x + grid.w; let oldB = grid.y + grid.h;
        grid.x = x; grid.y = y;
        grid.w = oldR - grid.x; grid.h = oldB - grid.y;
    } else if(dragHandle === 'br') {
        grid.w = x - grid.x; grid.h = y - grid.y;
    }
    draw();
});
canvas.addEventListener('mouseup', () => { isDragging = false; dragHandle = null; });
const dist = (x1,y1,x2,y2) => Math.sqrt((x1-x2)**2 + (y1-y2)**2);

document.getElementById('colCount').addEventListener('input', draw);
document.getElementById('rowCount').addEventListener('input', draw);


// --- 3. æ ¸å¿ƒåˆ†æé€»è¾‘ ---
async function runAnalysis() {
    if(!img.src) { alert("è¯·å…ˆä¸Šä¼ å›¾ç‰‡"); return; }
    
    showLoading(true, "æ­£åœ¨åˆ†æåƒç´ ...");
    
    // 0. å‡†å¤‡æ•°æ®
    const cols = parseInt(document.getElementById('colCount').value);
    const rows = parseInt(document.getElementById('rowCount').value);
    const cellW = grid.w / cols;
    const cellH = grid.h / rows;
    
    // åˆå§‹åŒ–æœ‰æ•ˆåˆ— (åˆå§‹çŠ¶æ€æ‰€æœ‰åˆ—éƒ½æœ‰æ•ˆ)
    validCols = Array.from({length: cols}, (_, i) => i);
    
    // 1. é¢œè‰²è¯†åˆ« (å…¥ä½åˆ¤æ–­)
    rawData = [];
    const imgData = ctx.getImageData(0, 0, canvas.width, canvas.height).data;
    
    for(let r=0; r<rows; r++) {
        let rowData = [];
        for(let c=0; c<cols; c++) {
            // å®šä¹‰é‡‡æ ·åŒºåŸŸï¼šæ ¼å­çš„ä¸­é—´ 50% åŒºåŸŸï¼Œé¿å¼€è¾¹æ¡†å¹²æ‰°
            const startX = Math.floor(grid.x + c*cellW + cellW*0.25);
            const startY = Math.floor(grid.y + r*cellH + cellH*0.25);
            const w = Math.floor(cellW * 0.5);
            const h = Math.floor(cellH * 0.5);
            
            let coloredPixels = 0;
            let totalPixels = 0;
            
            for(let py=startY; py<startY+h; py++) {
                for(let px=startX; px<startX+w; px++) {
                    const i = (py * canvas.width + px) * 4;
                    const R = imgData[i], G = imgData[i+1], B = imgData[i+2];
                    
                    // é¢œè‰²åˆ¤æ–­ç®—æ³•ï¼š
                    // èƒŒæ™¯é€šå¸¸æ˜¯ç™½è‰²/æµ…ç° (240~255)ã€‚
                    // å¦‚æœ RGB ä»»æ„ä¸€ä¸ªåˆ†é‡ < 235ï¼Œè¯´æ˜æœ‰é¢œè‰²ã€‚
                    if(R < 235 || G < 235 || B < 235) {
                        coloredPixels++;
                    }
                    totalPixels++;
                }
            }
            
            // å¯†åº¦é˜ˆå€¼ï¼šå¦‚æœåŒºåŸŸå†…è¶…è¿‡ 5% çš„åƒç´ æœ‰é¢œè‰²ï¼Œåˆ™åˆ¤å®šä¸ºå…¥ä½
            // è¿™è§£å†³äº†â€œå‘å²›202â€è¿™ç§çº¯ç™½æ ¼å­è¢«è¯¯åˆ¤çš„é—®é¢˜
            const density = coloredPixels / totalPixels;
            rowData.push(density > 0.05 ? 1 : 0);
        }
        rawData.push(rowData);
    }

    // 2. OCR è¯†åˆ«è¡¨å¤´
    showLoading(true, "æ­£åœ¨è¯†åˆ«æˆ¿å (OCR)...");
    roomNames = await performOCR(cols, cellW);
    
    // 3. ç”Ÿæˆæ—¥æœŸ
    dateList = [];
    const startD = new Date(document.getElementById('startDate').value);
    for(let i=0; i<rows; i++) {
        let d = new Date(startD);
        d.setDate(d.getDate() + i);
        dateList.push(`${d.getMonth()+1}/${d.getDate()}`);
    }

    showLoading(false);
    document.getElementById('resultCard').style.display = 'block';
    renderResultTable();
    updateCharts();
}

// OCR é€»è¾‘
async function performOCR(cols, cellW) {
    const names = [];
    const worker = await Tesseract.createWorker('chi_sim'); // åŠ è½½ä¸­æ–‡æ¨¡å‹
    
    // è®¡ç®—è¡¨å¤´åŒºåŸŸé«˜åº¦ (å‡è®¾åœ¨ç½‘æ ¼ä¸Šæ–¹ 60px èŒƒå›´å†…)
    const headerH = Math.min(80, grid.y);
    const headerY = grid.y - headerH;
    
    // éå†æ¯ä¸€åˆ—è¿›è¡Œè¯†åˆ«
    for(let i=0; i<cols; i++) {
        // æ›´æ–°åŠ è½½è¿›åº¦
        document.getElementById('loadingText').innerText = `æ­£åœ¨è¯†åˆ«ç¬¬ ${i+1}/${cols} åˆ—æˆ¿å...`;
        
        // è£å‰ªè¯¥åˆ—é¡¶éƒ¨çš„å›¾åƒ
        const x = grid.x + i * cellW;
        
        // åˆ›å»ºä¸´æ—¶ç”»å¸ƒå­˜è£å‰ªå›¾
        const tmpCan = document.createElement('canvas');
        tmpCan.width = cellW; 
        tmpCan.height = headerH;
        const tCtx = tmpCan.getContext('2d');
        // ä»åŸå›¾ç»˜åˆ¶åˆ°ä¸´æ—¶ç”»å¸ƒ
        tCtx.drawImage(img, 
            x / (canvas.width/img.width), headerY / (canvas.height/img.height), // source x,y (mapping back to raw img)
            cellW / (canvas.width/img.width), headerH / (canvas.height/img.height), // source w,h
            0, 0, cellW, headerH // dest
        );
        
        // è¯†åˆ«
        const { data: { text } } = await worker.recognize(tmpCan);
        // æ¸…ç†æ¢è¡Œç¬¦å’Œç©ºæ ¼
        let cleanText = text.replace(/\s/g, '');
        names.push(cleanText || `æˆ¿${i+1}`); // è¯†åˆ«å¤±è´¥åˆ™å›é€€é»˜è®¤
    }
    
    await worker.terminate();
    return names;
}

// --- 4. æ¸²æŸ“ç»“æœ & åŠ¨æ€åˆ—ç®¡ç† ---

function renderResultTable() {
    const table = document.getElementById('dataTable');
    table.innerHTML = '';
    
    // THEAD
    let thead = document.createElement('thead');
    let trHead = document.createElement('tr');
    trHead.innerHTML = '<th>æ—¥æœŸ</th>';
    
    validCols.forEach(colIdx => {
        let th = document.createElement('th');
        // è¾“å…¥æ¡†å…è®¸ä¿®æ”¹æˆ¿å
        let input = document.createElement('input');
        input.className = 'th-input';
        input.value = roomNames[colIdx];
        input.onchange = (e) => { roomNames[colIdx] = e.target.value; updateCharts(); };
        
        // åˆ é™¤æŒ‰é’®
        let delBtn = document.createElement('button');
        delBtn.className = 'btn-danger';
        delBtn.innerText = 'ğŸ—‘ï¸';
        delBtn.title = "åˆ é™¤æ­¤åˆ— (å¦‚ç©ºç™½é—´éš”)";
        delBtn.onclick = () => deleteColumn(colIdx);
        
        th.appendChild(input);
        th.appendChild(delBtn);
        trHead.appendChild(th);
    });
    thead.appendChild(trHead);
    table.appendChild(thead);

    // TBODY
    let tbody = document.createElement('tbody');
    for(let r=0; r<rawData.length; r++) {
        let tr = document.createElement('tr');
        // æ—¥æœŸåˆ—
        let tdDate = document.createElement('td');
        tdDate.innerText = dateList[r];
        tr.appendChild(tdDate);
        
        // æ•°æ®åˆ—
        validCols.forEach(c => {
            let td = document.createElement('td');
            let isOcc = rawData[r][c] === 1;
            if(isOcc) td.className = 'occupied';
            
            // ç‚¹å‡»åˆ‡æ¢çŠ¶æ€ (ä¿®æ­£è¯¯åˆ¤)
            td.onclick = function() {
                rawData[r][c] = rawData[r][c] ? 0 : 1;
                this.className = rawData[r][c] ? 'occupied' : '';
                updateCharts();
            };
            
            // å¯é€‰ï¼šæ˜¾ç¤º âœ“
            td.innerText = isOcc ? 'âœ“' : '';
            tr.appendChild(td);
        });
        tbody.appendChild(tr);
    }
    table.appendChild(tbody);
    
    updateCharts();
}

function deleteColumn(colIndex) {
    if(confirm("ç¡®å®šè¦åˆ é™¤è¿™ä¸€åˆ—å—ï¼Ÿ(é€šå¸¸ç”¨äºåˆ é™¤ä¸­é—´çš„ç©ºç™½é—´éš”)")) {
        validCols = validCols.filter(c => c !== colIndex);
        renderResultTable(); // é‡ç»˜è¡¨æ ¼
    }
}

// --- 5. ç»Ÿè®¡ä¸å›¾è¡¨ ---
function updateCharts() {
    const rows = rawData.length;
    const realCols = validCols.length;
    if(realCols === 0) return;

    // ç»Ÿè®¡æ•°æ®
    let totalSlots = rows * realCols;
    let totalOccupied = 0;
    
    // å„æˆ¿å…¥ä½ç‡
    let roomSeries = validCols.map(c => {
        let occ = 0;
        for(let r=0; r<rows; r++) occ += rawData[r][c];
        totalOccupied += occ;
        return (occ / rows * 100).toFixed(1);
    });
    
    // æ¯æ—¥å…¥ä½ç‡
    let dateSeries = [];
    for(let r=0; r<rows; r++) {
        let occ = 0;
        validCols.forEach(c => occ += rawData[r][c]);
        dateSeries.push((occ / realCols * 100).toFixed(1));
    }

    // æ›´æ–°é¢æ¿
    document.getElementById('valTotalSlots').innerText = totalSlots;
    document.getElementById('valOccupied').innerText = totalOccupied;
    document.getElementById('valRate').innerText = (totalOccupied/totalSlots*100).toFixed(1) + "%";

    // ç»˜åˆ¶ ECharts
    renderEChart(roomSeries, dateSeries);
}

let myChart = null;
function renderEChart(roomData, dateData) {
    if(myChart) myChart.dispose();
    myChart = echarts.init(document.getElementById('chartMain'));
    
    const validNames = validCols.map(c => roomNames[c]);
    
    const option = {
        tooltip: { trigger: 'axis' },
        legend: { data: ['æˆ¿é—´å…¥ä½ç‡', 'æ¯æ—¥è¶‹åŠ¿'] },
        grid: { bottom: 80 },
        xAxis: [
            { type: 'category', data: validNames, axisLabel: { rotate: 45 } },
            { type: 'category', data: dateList, show: false } // éšè—çš„è½´ç”¨äºæŠ˜çº¿å›¾æ˜ å°„
        ],
        yAxis: { type: 'value', max: 100, name: 'ç™¾åˆ†æ¯” %' },
        series: [
            {
                name: 'æˆ¿é—´å…¥ä½ç‡',
                type: 'bar',
                data: roomData,
                itemStyle: { color: '#0071e3' },
                label: { show: true, position: 'top', formatter: '{c}%' }
            },
            {
                name: 'æ¯æ—¥è¶‹åŠ¿',
                type: 'line',
                smooth: true,
                data: dateData,
                xAxisIndex: 0, // è¿™é‡Œçš„é€»è¾‘æ˜¯æ··åˆæ˜¾ç¤ºï¼Œç®€åŒ–èµ·è§æš‚ç”¨åŒä¸€Xè½´ï¼Œå®é™…åº”ç”¨ä¸­å»ºè®®åˆ†tabæ˜¾ç¤º
                itemStyle: { color: '#34c759' },
                lineStyle: { width: 3 }
            }
        ]
    };
    
    // å¦‚æœæ˜¯ Chart Tab æ¨¡å¼ï¼Œæ˜¾ç¤ºä¸åŒçš„å›¾
    // è¿™é‡Œä¸ºäº†ç®€å•ï¼Œæ··åˆæ˜¾ç¤ºã€‚è‹¥éœ€åˆ†ç¦»å¯å¢åŠ é€»è¾‘ã€‚
    myChart.setOption(option);
}

// --- 6. å·¥å…·å‡½æ•° ---
function switchTab(mode) {
    document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
    event.target.classList.add('active');
    
    document.getElementById('viewTable').style.display = mode === 'table' ? 'block' : 'none';
    document.getElementById('viewChart').style.display = mode === 'chart' ? 'block' : 'none';
    if(mode === 'chart') setTimeout(() => myChart && myChart.resize(), 100);
}

function exportExcel() {
    let wb = XLSX.utils.book_new();
    let wsData = [];
    
    // Header
    let headers = ['æ—¥æœŸ'];
    validCols.forEach(c => headers.push(roomNames[c]));
    headers.push('å½“æ—¥å…¥ä½ç‡');
    wsData.push(headers);
    
    // Rows
    for(let r=0; r<rawData.length; r++) {
        let row = [dateList[r]];
        let dayOcc = 0;
        validCols.forEach(c => {
            let isOcc = rawData[r][c] === 1;
            row.push(isOcc ? '1' : ''); // Excelé‡Œæ˜¾ç¤º1æ–¹ä¾¿ç»Ÿè®¡
            if(isOcc) dayOcc++;
        });
        row.push((dayOcc/validCols.length*100).toFixed(1)+'%');
        wsData.push(row);
    }
    
    let ws = XLSX.utils.aoa_to_sheet(wsData);
    XLSX.utils.book_append_sheet(wb, ws, "å…¥ä½ç»Ÿè®¡");
    XLSX.writeFile(wb, "å…¥ä½ç‡åˆ†ææŠ¥å‘Š.xlsx");
}

function showLoading(show, text) {
    const el = document.getElementById('loading');
    el.style.display = show ? 'flex' : 'none';
    if(text) document.getElementById('loadingText').innerText = text;
}

window.onresize = () => { initCanvas(); if(myChart) myChart.resize(); };
</script>
</body>
</html>
