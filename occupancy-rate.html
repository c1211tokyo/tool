<!DOCTYPE html>
<html lang="zh">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>æ™ºèƒ½å…¥ä½ç‡åˆ†æç³»ç»Ÿ (ç¨³å®šç‰ˆ)</title>
<script src="https://cdn.jsdelivr.net/npm/echarts/dist/echarts.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/xlsx@0.18.5/dist/xlsx.full.min.js"></script>
<script src='https://cdn.jsdelivr.net/npm/tesseract.js@4.1.1/dist/tesseract.min.js'></script>

<style>
    :root { --primary: #0071e3; --bg: #f5f5f7; --card: #fff; --border: #d2d2d7; }
    body { font-family: -apple-system, sans-serif; background: var(--bg); color: #1d1d1f; margin: 0; padding: 20px; }
    .container { max-width: 1280px; margin: 0 auto; }
    
    header { text-align: center; margin-bottom: 20px; }
    .card { background: var(--card); border-radius: 12px; padding: 20px; box-shadow: 0 4px 12px rgba(0,0,0,0.05); margin-bottom: 20px; }
    
    .controls { display: flex; gap: 15px; flex-wrap: wrap; align-items: center; background: #f9f9f9; padding: 15px; border-radius: 8px; }
    .control-group { display: flex; flex-direction: column; gap: 4px; }
    .control-group label { font-size: 12px; color: #666; font-weight: 500; }
    input[type="number"], input[type="date"] { padding: 6px; border: 1px solid var(--border); border-radius: 6px; width: 100px; }
    
    .btn { background: var(--primary); color: white; border: none; padding: 8px 18px; border-radius: 6px; font-size: 13px; cursor: pointer; transition: 0.2s; display: flex; align-items: center; gap: 6px; }
    .btn:hover { background: #0077ed; }
    .btn-danger { background: #ff3b30; padding: 2px 8px; font-size: 12px; margin-left: 4px; border-radius: 4px; cursor: pointer; color:white; border:none;}
    
    .canvas-container { position: relative; overflow: auto; text-align: center; background: #333; border-radius: 8px; padding: 10px; max-height: 80vh; }
    canvas { max-width: 100%; box-shadow: 0 0 10px rgba(0,0,0,0.3); }

    .tabs { display: flex; gap: 10px; border-bottom: 1px solid var(--border); padding-bottom: 10px; margin-bottom: 15px; }
    .tab { padding: 6px 16px; border-radius: 20px; cursor: pointer; font-size: 13px; background: #f0f0f0; color: #666; }
    .tab.active { background: var(--primary); color: white; }

    /* è¡¨æ ¼æ ·å¼ */
    .table-wrap { overflow-x: auto; max-height: 600px; }
    table { width: 100%; border-collapse: collapse; font-size: 12px; white-space: nowrap; }
    th, td { border: 1px solid #e5e5e5; padding: 6px 4px; text-align: center; }
    th { background: #f2f2f7; font-weight: 600; position: sticky; top: 0; z-index: 10; }
    
    .occupied { background-color: rgba(52, 199, 89, 0.25) !important; } 
    
    /* åŠ è½½é®ç½© */
    .loading-overlay { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(255,255,255,0.95); z-index: 999; display: none; flex-direction: column; justify-content: center; align-items: center; }
    .spinner { width: 40px; height: 40px; border: 4px solid #f3f3f3; border-top: 4px solid var(--primary); border-radius: 50%; animation: spin 1s linear infinite; }
    @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
    
    .skip-btn { margin-top: 20px; padding: 8px 20px; background: #fff; border: 1px solid #ccc; color: #666; border-radius: 20px; cursor: pointer; font-size: 13px; }
    .skip-btn:hover { background: #eee; color: #333; }

    .th-input { border: none; background: transparent; font-weight: bold; width: 80px; text-align: center; font-size: 12px; }
    .th-input:focus { outline: 2px solid var(--primary); background: #fff; }
</style>
</head>
<body>

<div class="loading-overlay" id="loading">
    <div class="spinner"></div>
    <p id="loadingText" style="margin-top:15px; font-weight:500; color:#333">æ­£åœ¨åˆå§‹åŒ–...</p>
    <p style="font-size:12px; color:#999; margin-top:5px;">å¦‚æœå¡ä½è¶…è¿‡10ç§’ï¼Œè¯·ç‚¹å‡»ä¸‹æ–¹æŒ‰é’®è·³è¿‡</p>
    <button class="skip-btn" onclick="forceSkipOCR()">è·³è¿‡ OCR (ç›´æ¥ç”Ÿæˆè¡¨æ ¼)</button>
</div>

<div class="container">
    <header>
        <h1>æ™ºèƒ½å…¥ä½ç‡åˆ†æç³»ç»Ÿ <span style="font-size:14px; color:#fff; background:#34c759; padding:2px 6px; border-radius:4px; vertical-align:middle;">ç¨³å®šç‰ˆ</span></h1>
    </header>

    <div class="card">
        <div class="controls">
            <div class="control-group">
                <label>1. ä¸Šä¼ å›¾ç‰‡</label>
                <input type="file" id="imgInput" accept="image/*">
            </div>
            <div class="control-group">
                <label>2. æˆ¿é—´æ•° (åˆ—)</label>
                <input type="number" id="colCount" value="15" min="1">
            </div>
            <div class="control-group">
                <label>3. ç»Ÿè®¡å¤©æ•° (è¡Œ)</label>
                <input type="number" id="rowCount" value="30" min="1">
            </div>
            <div class="control-group">
                <label>4. èµ·å§‹æ—¥æœŸ</label>
                <input type="date" id="startDate">
            </div>
            <div style="flex-grow:1; text-align:right;">
                <button class="btn" onclick="runAnalysis()">
                    âš¡ å¼€å§‹åˆ†æ
                </button>
            </div>
        </div>
        
        <div style="font-size: 12px; color: #86868b; margin-top: 5px; background: #fffbe6; border: 1px solid #ffe58f; padding: 8px; border-radius: 4px;">
            <strong>æç¤ºï¼š</strong> ä¸Šä¼ åï¼Œè¯·è°ƒæ•´<strong>çº¢æ¡†</strong>ä»…è¦†ç›–ä¸­é—´çš„å½©è‰²æ ¼å­åŒºåŸŸã€‚è¯·è°ƒæ•´<strong>åˆ—æ•°</strong>ç¡®ä¿çº¢è‰²ç«–çº¿å¯¹é½æ¯ä¸€åˆ—ï¼ˆåŒ…æ‹¬ç©ºç™½åˆ—ï¼‰ã€‚
        </div>

        <div class="canvas-container">
            <canvas id="mainCanvas"></canvas>
        </div>
    </div>

    <div class="card" id="resultCard" style="display:none;">
        <div class="tabs">
            <div class="tab active" onclick="switchTab('table')">ğŸ“Š æ•°æ®è¡¨æ ¼</div>
            <div class="tab" onclick="switchTab('chart')">ğŸ“ˆ ç»Ÿè®¡å›¾è¡¨</div>
            <button class="btn" style="margin-left:auto; background:#34c759;" onclick="exportExcel()">ğŸ“¥ å¯¼å‡º Excel</button>
        </div>

        <div style="display:flex; gap:20px; margin-bottom:15px; padding:10px; background:#f5f7fa; border-radius:8px; font-size:13px;">
            <div>æ€»æˆ¿æ™š: <strong id="valTotalSlots">-</strong></div>
            <div>å®é™…å…¥ä½: <strong id="valOccupied" style="color:#34c759">-</strong></div>
            <div>æ€»å…¥ä½ç‡: <strong id="valRate" style="color:#0071e3">-</strong></div>
        </div>

        <div id="viewTable" class="table-wrap">
            <table id="dataTable"></table>
        </div>

        <div id="viewChart" style="display:none;">
            <div id="chartMain" style="width: 100%; height: 450px;"></div>
        </div>
    </div>
</div>

<script>
// --- å…¨å±€å˜é‡ ---
let img = new Image();
let canvas = document.getElementById('mainCanvas');
let ctx = canvas.getContext('2d');
let grid = { x: 50, y: 100, w: 0, h: 0 }; 
let isDragging = false;
let dragHandle = null;
let rawData = [];
let roomNames = [];
let dateList = [];
let validCols = [];
let skipOCRFlag = false; // è·³è¿‡æ ‡è®°

document.getElementById('startDate').valueAsDate = new Date();

// --- å›¾ç‰‡å¤„ç† ---
document.getElementById('imgInput').addEventListener('change', function(e) {
    if(!e.target.files[0]) return;
    const reader = new FileReader();
    reader.onload = function(evt) {
        img.onload = function() { initCanvas(); }
        img.src = evt.target.result;
    }
    reader.readAsDataURL(e.target.files[0]);
});

function initCanvas() {
    const maxWidth = 1200;
    const scale = Math.min(1, maxWidth / img.width);
    canvas.width = img.width * scale;
    canvas.height = img.height * scale;
    
    grid.x = canvas.width * 0.05;
    grid.y = canvas.height * 0.15; 
    grid.w = canvas.width * 0.9;
    grid.h = canvas.height * 0.8;
    draw();
}

// --- ç»˜å›¾ä¸äº¤äº’ ---
function draw() {
    if (!ctx) return;
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    ctx.drawImage(img, 0, 0, canvas.width, canvas.height);

    ctx.fillStyle = 'rgba(0,0,0,0.4)';
    ctx.fillRect(0,0,canvas.width, grid.y);
    ctx.fillRect(0,grid.y+grid.h,canvas.width, canvas.height-(grid.y+grid.h));
    ctx.fillRect(0,grid.y,grid.x,grid.h);
    ctx.fillRect(grid.x+grid.w, grid.y, canvas.width-(grid.x+grid.w), grid.h);

    ctx.strokeStyle = '#ff3b30';
    ctx.lineWidth = 2;
    ctx.strokeRect(grid.x, grid.y, grid.w, grid.h);

    // ç»˜åˆ¶OCRåŒºåŸŸæç¤º(é»„è‰²)
    const headerHeight = Math.min(grid.y, 80); 
    ctx.save();
    ctx.strokeStyle = '#ffcc00'; ctx.setLineDash([4, 4]); ctx.strokeRect(grid.x, grid.y - headerHeight, grid.w, headerHeight);
    ctx.restore();

    const cols = parseInt(document.getElementById('colCount').value) || 1;
    const rows = parseInt(document.getElementById('rowCount').value) || 1;
    
    ctx.beginPath();
    ctx.strokeStyle = 'rgba(255, 59, 48, 0.5)';
    ctx.lineWidth = 1;
    const cellW = grid.w / cols;
    for(let i=1; i<cols; i++) { let x = grid.x + i * cellW; ctx.moveTo(x, grid.y); ctx.lineTo(x, grid.y + grid.h); }
    const cellH = grid.h / rows;
    for(let i=1; i<rows; i++) { let y = grid.y + i * cellH; ctx.moveTo(grid.x, y); ctx.lineTo(grid.x + grid.w, y); }
    ctx.stroke();

    drawHandle(grid.x, grid.y);
    drawHandle(grid.x+grid.w, grid.y+grid.h);
}

function drawHandle(x, y) {
    ctx.beginPath(); ctx.arc(x, y, 8, 0, Math.PI*2); ctx.fillStyle = '#fff'; ctx.fill(); ctx.strokeStyle = '#0071e3'; ctx.stroke();
}

canvas.addEventListener('mousedown', e => {
    const rect = canvas.getBoundingClientRect();
    const x = (e.clientX - rect.left) * (canvas.width / rect.width);
    const y = (e.clientY - rect.top) * (canvas.height / rect.height);
    if(dist(x,y, grid.x, grid.y) < 20) dragHandle = 'tl';
    else if(dist(x,y, grid.x+grid.w, grid.y+grid.h) < 20) dragHandle = 'br';
    else if(x>grid.x && x<grid.x+grid.w && y>grid.y && y<grid.y+grid.h) { dragHandle = 'move'; canvas.lastX = x; canvas.lastY = y; }
    if(dragHandle) isDragging = true;
});
canvas.addEventListener('mousemove', e => {
    if(!isDragging) return;
    const rect = canvas.getBoundingClientRect();
    const x = (e.clientX - rect.left) * (canvas.width / rect.width);
    const y = (e.clientY - rect.top) * (canvas.height / rect.height);
    if(dragHandle === 'move') { grid.x += x - canvas.lastX; grid.y += y - canvas.lastY; canvas.lastX = x; canvas.lastY = y; }
    else if(dragHandle === 'tl') { let oldR = grid.x + grid.w; let oldB = grid.y + grid.h; grid.x = x; grid.y = y; grid.w = oldR - grid.x; grid.h = oldB - grid.y; }
    else if(dragHandle === 'br') { grid.w = x - grid.x; grid.h = y - grid.y; }
    draw();
});
canvas.addEventListener('mouseup', () => { isDragging = false; dragHandle = null; });
const dist = (x1,y1,x2,y2) => Math.sqrt((x1-x2)**2 + (y1-y2)**2);
document.getElementById('colCount').addEventListener('input', draw);
document.getElementById('rowCount').addEventListener('input', draw);

// --- å¼ºåˆ¶è·³è¿‡ OCR ---
function forceSkipOCR() {
    skipOCRFlag = true;
}

// --- æ ¸å¿ƒåˆ†æ ---
async function runAnalysis() {
    if(!img.src) { alert("è¯·å…ˆä¸Šä¼ å›¾ç‰‡"); return; }
    
    const cols = parseInt(document.getElementById('colCount').value);
    const rows = parseInt(document.getElementById('rowCount').value);
    const cellW = grid.w / cols;
    const cellH = grid.h / rows;
    
    // 0. åƒç´ é¢œè‰²åˆ†æ (ç«‹å³æ‰§è¡Œ)
    showLoading(true, "æ­£åœ¨åˆ†æåƒç´ å…¥ä½çŠ¶æ€...");
    rawData = [];
    const imgData = ctx.getImageData(0, 0, canvas.width, canvas.height).data;
    
    for(let r=0; r<rows; r++) {
        let rowData = [];
        for(let c=0; c<cols; c++) {
            const startX = Math.floor(grid.x + c*cellW + cellW*0.25);
            const startY = Math.floor(grid.y + r*cellH + cellH*0.25);
            const w = Math.floor(cellW * 0.5);
            const h = Math.floor(cellH * 0.5);
            let colored = 0, total = 0;
            for(let py=startY; py<startY+h; py++) {
                for(let px=startX; px<startX+w; px++) {
                    const i = (py * canvas.width + px) * 4;
                    // åªè¦ RGB ä»»æ„åˆ†é‡å°äº 235ï¼Œå°±è®¤ä¸ºä¸æ˜¯ç™½è‰²èƒŒæ™¯
                    if(imgData[i] < 235 || imgData[i+1] < 235 || imgData[i+2] < 235) colored++;
                    total++;
                }
            }
            // å¯†åº¦ > 5% åˆ¤å®šä¸ºå…¥ä½ (è§£å†³ç©ºç™½åˆ—å’Œç©ºæˆ¿é—®é¢˜)
            rowData.push( (colored/total) > 0.05 ? 1 : 0 );
        }
        rawData.push(rowData);
    }

    // 1. OCR è¯†åˆ« (å¸¦è·³è¿‡åŠŸèƒ½)
    skipOCRFlag = false;
    roomNames = [];
    validCols = Array.from({length: cols}, (_, i) => i); // é»˜è®¤å…¨é€‰

    // å°è¯• OCR
    try {
        await runOCRWithSkip(cols, cellW);
    } catch (e) {
        console.warn("OCR Error or Skipped", e);
        // è¡¥å…¨é»˜è®¤åç§°
        for(let i=roomNames.length; i<cols; i++) roomNames.push(`æˆ¿${i+1}`);
    }

    // 2. ç”Ÿæˆæ—¥æœŸ
    dateList = [];
    const startD = new Date(document.getElementById('startDate').value);
    for(let i=0; i<rows; i++) {
        let d = new Date(startD);
        d.setDate(d.getDate() + i);
        dateList.push(`${d.getMonth()+1}/${d.getDate()}`);
    }

    showLoading(false);
    document.getElementById('resultCard').style.display = 'block';
    renderResultTable();
    updateCharts();
}

// å°è£… OCR é€»è¾‘ï¼Œæ”¯æŒä¸­æ–­
async function runOCRWithSkip(cols, cellW) {
    const worker = await Tesseract.createWorker();
    
    document.getElementById('loadingText').innerText = "æ­£åœ¨åŠ è½½è¯­è¨€åŒ… (chi_sim)...";
    // å¦‚æœè¿™é‡Œå¡ä½ï¼Œç”¨æˆ·å¯ä»¥ç‚¹è·³è¿‡ï¼ŒskipOCRFlag ä¼šå˜ true
    
    // æ£€æŸ¥è·³è¿‡
    if(skipOCRFlag) throw new Error("Skipped");

    await worker.loadLanguage('chi_sim');
    await worker.initialize('chi_sim');

    const headerH = Math.min(80, grid.y);
    const headerY = grid.y - headerH;

    for(let i=0; i<cols; i++) {
        if(skipOCRFlag) { await worker.terminate(); throw new Error("Skipped"); }

        document.getElementById('loadingText').innerText = `æ­£åœ¨è¯†åˆ«ç¬¬ ${i+1}/${cols} åˆ—æˆ¿å...`;
        
        // è£å‰ªå°å›¾
        const tmpCan = document.createElement('canvas');
        // ç¼©å°ä¸€å€ä»¥åŠ é€Ÿ OCR
        const scaleFactor = 0.8; 
        tmpCan.width = cellW * scaleFactor; 
        tmpCan.height = headerH * scaleFactor;
        const tCtx = tmpCan.getContext('2d');
        
        // ç»˜åˆ¶è£å‰ªåŒº
        tCtx.drawImage(img, 
            (grid.x + i*cellW) / (canvas.width/img.width), 
            headerY / (canvas.height/img.height), 
            cellW / (canvas.width/img.width), 
            headerH / (canvas.height/img.height), 
            0, 0, tmpCan.width, tmpCan.height
        );
        
        // è¯†åˆ«
        const { data: { text } } = await worker.recognize(tmpCan);
        let name = text.replace(/\s/g, '').replace(/[^\u4e00-\u9fa5a-zA-Z0-9]/g, ''); // ä»…ä¿ç•™ä¸­æ–‡è‹±æ–‡æ•°å­—
        roomNames.push(name || `æˆ¿${i+1}`);
    }
    await worker.terminate();
}


// --- æ¸²æŸ“ç»“æœ ---
function renderResultTable() {
    const table = document.getElementById('dataTable');
    table.innerHTML = '';
    
    let thead = document.createElement('thead');
    let trHead = document.createElement('tr');
    trHead.innerHTML = '<th>æ—¥æœŸ</th>';
    
    validCols.forEach(colIdx => {
        let th = document.createElement('th');
        let div = document.createElement('div');
        div.style.display = 'flex'; div.style.alignItems='center'; div.style.justifyContent='center'; div.style.gap='4px';

        let input = document.createElement('input');
        input.className = 'th-input';
        input.value = roomNames[colIdx];
        input.onchange = (e) => { roomNames[colIdx] = e.target.value; updateCharts(); };
        
        let delBtn = document.createElement('button');
        delBtn.className = 'btn-danger';
        delBtn.innerText = 'X';
        delBtn.title = "åˆ é™¤æ­¤åˆ— (å¦‚ç©ºç™½é—´éš”)";
        delBtn.onclick = () => {
            if(confirm("ç¡®è®¤åˆ é™¤æ­¤åˆ—ï¼Ÿ")) {
                validCols = validCols.filter(c => c !== colIdx);
                renderResultTable();
            }
        };
        
        div.appendChild(input);
        div.appendChild(delBtn);
        th.appendChild(div);
        trHead.appendChild(th);
    });
    thead.appendChild(trHead);
    table.appendChild(thead);

    let tbody = document.createElement('tbody');
    for(let r=0; r<rawData.length; r++) {
        let tr = document.createElement('tr');
        let tdDate = document.createElement('td');
        tdDate.innerText = dateList[r];
        tr.appendChild(tdDate);
        
        validCols.forEach(c => {
            let td = document.createElement('td');
            let isOcc = rawData[r][c] === 1;
            if(isOcc) td.className = 'occupied';
            td.onclick = function() {
                rawData[r][c] = rawData[r][c] ? 0 : 1;
                this.className = rawData[r][c] ? 'occupied' : '';
                updateCharts();
            };
            tr.appendChild(td);
        });
        tbody.appendChild(tr);
    }
    table.appendChild(tbody);
    updateCharts();
}

function updateCharts() {
    const rows = rawData.length;
    const realCols = validCols.length;
    if(realCols === 0) return;

    let totalSlots = rows * realCols;
    let totalOccupied = 0;
    
    let roomSeries = validCols.map(c => {
        let occ = 0;
        for(let r=0; r<rows; r++) occ += rawData[r][c];
        totalOccupied += occ;
        return (occ / rows * 100).toFixed(1);
    });
    
    let dateSeries = [];
    for(let r=0; r<rows; r++) {
        let occ = 0;
        validCols.forEach(c => occ += rawData[r][c]);
        dateSeries.push((occ / realCols * 100).toFixed(1));
    }

    document.getElementById('valTotalSlots').innerText = totalSlots;
    document.getElementById('valOccupied').innerText = totalOccupied;
    document.getElementById('valRate').innerText = (totalOccupied/totalSlots*100).toFixed(1) + "%";

    renderEChart(roomSeries, dateSeries);
}

let myChart = null;
function renderEChart(roomData, dateData) {
    if(myChart) myChart.dispose();
    myChart = echarts.init(document.getElementById('chartMain'));
    const validNames = validCols.map(c => roomNames[c]);
    
    const option = {
        tooltip: { trigger: 'axis' },
        legend: { data: ['æˆ¿é—´å…¥ä½ç‡', 'æ¯æ—¥è¶‹åŠ¿'] },
        grid: { bottom: 80, left: 50, right: 20 },
        xAxis: [
            { type: 'category', data: validNames, axisLabel: { rotate: 45, fontSize: 11 } },
            { type: 'category', data: dateList, show: false }
        ],
        yAxis: { type: 'value', max: 100, name: '%' },
        series: [
            { name: 'æˆ¿é—´å…¥ä½ç‡', type: 'bar', data: roomData, itemStyle: { color: '#0071e3' }, label: { show: true, position: 'top', formatter: '{c}%' } },
            { name: 'æ¯æ—¥è¶‹åŠ¿', type: 'line', smooth: true, data: dateData, xAxisIndex: 0, itemStyle: { color: '#34c759' } }
        ]
    };
    myChart.setOption(option);
}

function switchTab(mode) {
    document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
    event.target.classList.add('active');
    document.getElementById('viewTable').style.display = mode === 'table' ? 'block' : 'none';
    document.getElementById('viewChart').style.display = mode === 'chart' ? 'block' : 'none';
    if(mode === 'chart') setTimeout(() => myChart && myChart.resize(), 100);
}

function exportExcel() {
    let wb = XLSX.utils.book_new();
    let wsData = [];
    let headers = ['æ—¥æœŸ'];
    validCols.forEach(c => headers.push(roomNames[c]));
    headers.push('å½“æ—¥å…¥ä½ç‡');
    wsData.push(headers);
    for(let r=0; r<rawData.length; r++) {
        let row = [dateList[r]];
        let dayOcc = 0;
        validCols.forEach(c => {
            let isOcc = rawData[r][c] === 1;
            row.push(isOcc ? '1' : ''); 
            if(isOcc) dayOcc++;
        });
        row.push((dayOcc/validCols.length*100).toFixed(1)+'%');
        wsData.push(row);
    }
    let ws = XLSX.utils.aoa_to_sheet(wsData);
    XLSX.utils.book_append_sheet(wb, ws, "å…¥ä½ç»Ÿè®¡");
    XLSX.writeFile(wb, "å…¥ä½ç‡åˆ†ææŠ¥å‘Š.xlsx");
}

function showLoading(show, text) {
    const el = document.getElementById('loading');
    el.style.display = show ? 'flex' : 'none';
    if(text) document.getElementById('loadingText').innerText = text;
}

window.onresize = () => { initCanvas(); if(myChart) myChart.resize(); };
</script>
</body>
</html>
