<!DOCTYPE html>
<html lang="zh">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>æ™ºèƒ½å…¥ä½ç‡åˆ†æç³»ç»Ÿ | è˜‡çš„å·¥å…·ç®±</title>
<script src="https://cdn.jsdelivr.net/npm/echarts/dist/echarts.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/xlsx@0.18.5/dist/xlsx.full.min.js"></script>
<script src='https://cdn.jsdelivr.net/npm/tesseract.js@4.1.1/dist/tesseract.min.js'></script>

<style>
    :root { --primary: #0071e3; --bg: #f5f5f7; --card: #fff; --border: #d2d2d7; }
    body { font-family: -apple-system, sans-serif; background: var(--bg); color: #1d1d1f; margin: 0; padding: 20px; }
    .container { max-width: 1280px; margin: 0 auto; }
    
    header { text-align: center; margin-bottom: 20px; }
    .card { background: var(--card); border-radius: 12px; padding: 20px; box-shadow: 0 4px 12px rgba(0,0,0,0.05); margin-bottom: 20px; }
    
    .controls { display: flex; gap: 15px; flex-wrap: wrap; align-items: center; background: #f9f9f9; padding: 15px; border-radius: 8px; }
    .control-group { display: flex; flex-direction: column; gap: 4px; }
    .control-group label { font-size: 12px; color: #666; font-weight: 500; }
    input[type="number"], input[type="date"] { padding: 6px; border: 1px solid var(--border); border-radius: 6px; width: 100px; }
    
    .btn { background: var(--primary); color: white; border: none; padding: 8px 18px; border-radius: 6px; font-size: 13px; cursor: pointer; transition: 0.2s; display: flex; align-items: center; gap: 6px; }
    .btn:hover { background: #0077ed; }
    .btn-secondary { background: #e5e5ea; color: #333; }
    .btn-danger { background: #ff3b30; color:white; border:none; padding: 2px 8px; border-radius: 4px; cursor: pointer; font-size: 12px;}
    
    .canvas-container { position: relative; overflow: hidden; text-align: center; background: #333; border-radius: 8px; padding: 10px; height: 70vh; display:flex; justify-content: center; align-items: center;}
    canvas { max-width: 100%; max-height: 100%; box-shadow: 0 0 10px rgba(0,0,0,0.3); cursor: crosshair; }

    .tabs { display: flex; gap: 10px; border-bottom: 1px solid var(--border); padding-bottom: 10px; margin-bottom: 15px; }
    .tab { padding: 6px 16px; border-radius: 20px; cursor: pointer; font-size: 13px; background: #f0f0f0; color: #666; }
    .tab.active { background: var(--primary); color: white; }

    .table-wrap { overflow-x: auto; max-height: 600px; }
    table { width: 100%; border-collapse: collapse; font-size: 12px; white-space: nowrap; }
    th, td { border: 1px solid #e5e5e5; padding: 6px 4px; text-align: center; }
    th { background: #f2f2f7; font-weight: 600; position: sticky; top: 0; z-index: 10; }
    
    .occupied { background-color: rgba(52, 199, 89, 0.25) !important; } 
    .th-input { border: none; background: transparent; font-weight: bold; width: 80px; text-align: center; font-size: 12px; }
    .th-input:focus { outline: 2px solid var(--primary); background: #fff; }

    /* åŠ è½½é®ç½© */
    .loading-overlay { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(255,255,255,0.95); z-index: 999; display: none; flex-direction: column; justify-content: center; align-items: center; }
    .spinner { width: 40px; height: 40px; border: 4px solid #f3f3f3; border-top: 4px solid var(--primary); border-radius: 50%; animation: spin 1s linear infinite; }
    @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
    .skip-btn { margin-top: 20px; padding: 8px 20px; background: #fff; border: 1px solid #ccc; color: #666; border-radius: 20px; cursor: pointer; }
</style>
</head>
<body>

<div class="loading-overlay" id="loading">
    <div class="spinner"></div>
    <p id="loadingText" style="margin-top:15px; font-weight:500;">æ­£åœ¨å¤„ç†...</p>
    <button class="skip-btn" onclick="forceSkipOCR()">è·³è¿‡æ–‡å­—è¯†åˆ« (ç›´æ¥å‡ºç»“æœ)</button>
</div>

<div class="container">
    <header>
        <h1>æ™ºèƒ½å…¥ä½ç‡åˆ†æ <span style="font-size:14px; color:#fff; background:#0071e3; padding:2px 6px; border-radius:4px; vertical-align:middle;">è‡ªç”±åˆ—å®½ç‰ˆ</span></h1>
    </header>

    <div class="card">
        <div class="controls">
            <div class="control-group">
                <label>1. ä¸Šä¼ å›¾ç‰‡</label>
                <input type="file" id="imgInput" accept="image/*">
            </div>
            <div class="control-group">
                <label>2. æˆ¿é—´æ•° (åˆ—)</label>
                <input type="number" id="colCount" value="15" min="1" onchange="resetDividers()">
            </div>
            <div class="control-group">
                <label>3. ç»Ÿè®¡å¤©æ•° (è¡Œ)</label>
                <input type="number" id="rowCount" value="30" min="1">
            </div>
            <div class="control-group">
                <label>4. èµ·å§‹æ—¥æœŸ</label>
                <input type="date" id="startDate">
            </div>
            <div style="flex-grow:1; text-align:right; display:flex; gap:10px; justify-content:flex-end;">
                <button class="btn btn-secondary" onclick="resetDividers()">ğŸ”„ é‡ç½®ç½‘æ ¼çº¿</button>
                <button class="btn" onclick="runAnalysis()">âš¡ å¼€å§‹åˆ†æ</button>
            </div>
        </div>
        
        <div style="font-size: 12px; color: #86868b; margin-top: 5px; background: #fffbe6; border: 1px solid #ffe58f; padding: 8px; border-radius: 4px;">
            <strong>âœ¨ æ–°åŠŸèƒ½ï¼š</strong> çº¢æ¡†é¡¶éƒ¨çš„<b>å°ç™½ç‚¹</b>å¯ä»¥å·¦å³æ‹–åŠ¨ï¼é‡åˆ°åˆ—å®½ä¸ä¸€è‡´æˆ–ä¸­é—´æœ‰ç©ºéš™æ—¶ï¼Œè¯·æ‹–åŠ¨ç«–çº¿å¯¹é½æ¯ä¸€åˆ—çš„è¾¹ç•Œã€‚
        </div>

        <div class="canvas-container">
            <canvas id="mainCanvas"></canvas>
        </div>
    </div>

    <div class="card" id="resultCard" style="display:none;">
        <div class="tabs">
            <div class="tab active" onclick="switchTab('table')">ğŸ“Š æ•°æ®è¡¨æ ¼ (ç‚¹å‡» X åˆ é™¤åˆ—)</div>
            <div class="tab" onclick="switchTab('chart')">ğŸ“ˆ ç»Ÿè®¡å›¾è¡¨</div>
            <button class="btn" style="margin-left:auto; background:#34c759;" onclick="exportExcel()">ğŸ“¥ å¯¼å‡º Excel</button>
        </div>

        <div style="display:flex; gap:20px; margin-bottom:15px; padding:10px; background:#f5f7fa; border-radius:8px; font-size:13px;">
            <div>æ€»æˆ¿æ™š: <strong id="valTotalSlots">-</strong></div>
            <div>å®é™…å…¥ä½: <strong id="valOccupied" style="color:#34c759">-</strong></div>
            <div>æ€»å…¥ä½ç‡: <strong id="valRate" style="color:#0071e3">-</strong></div>
        </div>

        <div id="viewTable" class="table-wrap">
            <table id="dataTable"></table>
        </div>

        <div id="viewChart" style="display:none;">
            <div id="chartMain" style="width: 100%; height: 450px;"></div>
        </div>
    </div>
</div>

<script>
// --- å…¨å±€å˜é‡ ---
let img = new Image();
let canvas = document.getElementById('mainCanvas');
let ctx = canvas.getContext('2d');
let grid = { x: 50, y: 100, w: 0, h: 0 }; 
// å­˜å‚¨æ¯ä¸€æ¡åˆ†å‰²çº¿çš„ç›¸å¯¹ä½ç½® (0.0 ~ 1.0)
let colDividers = []; 

let isDragging = false;
let dragTarget = null; // { type: 'box'|'divider', handle: 'tl'|'br'|index }

let rawData = [];
let roomNames = [];
let dateList = [];
let validCols = [];
let skipOCRFlag = false;

document.getElementById('startDate').valueAsDate = new Date();

// --- 1. å›¾ç‰‡åŠ è½½ä¸åˆå§‹åŒ– ---
document.getElementById('imgInput').addEventListener('change', function(e) {
    if(!e.target.files[0]) return;
    const reader = new FileReader();
    reader.onload = function(evt) {
        img.onload = function() { 
            // æ¯æ¬¡åŠ è½½æ–°å›¾ï¼Œé‡ç½®ç½‘æ ¼
            initCanvas(); 
            resetDividers();
        }
        img.src = evt.target.result;
    }
    reader.readAsDataURL(e.target.files[0]);
});

function initCanvas() {
    // é€‚é… Canvas å°ºå¯¸
    const maxWidth = 1600; // æé«˜åˆ†è¾¨ç‡ä»¥ä¾¿æ›´ç²¾å‡†æ“ä½œ
    const scale = Math.min(1, maxWidth / img.width);
    canvas.width = img.width * scale;
    canvas.height = img.height * scale;
    
    // åˆå§‹åŒ–å¤–æ¡† (ç•™å‡ºä¸Šæ–¹åš OCR å’Œ æ‰‹æŸ„)
    grid.x = canvas.width * 0.05;
    grid.y = canvas.height * 0.15; 
    grid.w = canvas.width * 0.9;
    grid.h = canvas.height * 0.75;
    
    draw();
}

function resetDividers() {
    const cols = parseInt(document.getElementById('colCount').value) || 1;
    colDividers = [];
    // ç”Ÿæˆ N-1 æ¡å†…éƒ¨å‡åˆ†çº¿
    for(let i=1; i<cols; i++) {
        colDividers.push(i / cols);
    }
    draw();
}

// --- 2. ç»˜å›¾æ ¸å¿ƒé€»è¾‘ ---
function draw() {
    if (!ctx) return;
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    ctx.drawImage(img, 0, 0, canvas.width, canvas.height);

    // 1. ç»˜åˆ¶é®ç½© (è®©éé€‰åŒºå˜æš—)
    ctx.fillStyle = 'rgba(0,0,0,0.5)';
    ctx.fillRect(0,0,canvas.width, grid.y); // ä¸Š
    ctx.fillRect(0,grid.y+grid.h,canvas.width, canvas.height-(grid.y+grid.h)); // ä¸‹
    ctx.fillRect(0,grid.y,grid.x,grid.h); // å·¦
    ctx.fillRect(grid.x+grid.w, grid.y, canvas.width-(grid.x+grid.w), grid.h); // å³

    // 2. ç»˜åˆ¶å¤–æ¡† (çº¢æ¡†)
    ctx.strokeStyle = '#ff3b30';
    ctx.lineWidth = 2;
    ctx.strokeRect(grid.x, grid.y, grid.w, grid.h);

    // 3. ç»˜åˆ¶å†…éƒ¨ç«–çº¿ (å¯è°ƒèŠ‚åˆ—å®½)
    const rows = parseInt(document.getElementById('rowCount').value) || 1;
    const cellH = grid.h / rows;

    // æ¨ªçº¿ (ç­‰åˆ†ï¼Œæš‚ä¸æ”¯æŒæ‹–æ‹½æ¨ªçº¿ï¼Œé€šå¸¸ä¸éœ€è¦)
    ctx.beginPath();
    ctx.strokeStyle = 'rgba(255, 59, 48, 0.3)';
    ctx.lineWidth = 1;
    for(let i=1; i<rows; i++) {
        let y = grid.y + i * cellH;
        ctx.moveTo(grid.x, y);
        ctx.lineTo(grid.x + grid.w, y);
    }
    ctx.stroke();

    // ç«–çº¿ (æ ¹æ® colDividers)
    ctx.beginPath();
    ctx.strokeStyle = '#ff3b30';
    ctx.lineWidth = 1.5;
    
    colDividers.forEach((ratio, idx) => {
        let x = grid.x + ratio * grid.w;
        ctx.moveTo(x, grid.y);
        ctx.lineTo(x, grid.y + grid.h);
        
        // ç»˜åˆ¶é¡¶éƒ¨æ‹–æ‹½å°åœ†ç‚¹
        // æ³¨æ„ï¼šè¿™é‡Œä¸åœ¨ path é‡Œç”»ï¼Œåˆ†å¼€ç”»
    });
    ctx.stroke();

    // ç»˜åˆ¶æ‰‹æŸ„
    // å¤–æ¡†æ‰‹æŸ„ (TL, BR)
    drawHandle(grid.x, grid.y, '#0071e3');
    drawHandle(grid.x+grid.w, grid.y+grid.h, '#0071e3');

    // åˆ—çº¿æ‰‹æŸ„ (Top Edge)
    colDividers.forEach((ratio) => {
        let x = grid.x + ratio * grid.w;
        drawHandle(x, grid.y, '#ffffff', '#ff3b30'); // ç™½åº•çº¢è¾¹
    });

    // ç»˜åˆ¶ OCR æç¤ºåŒº
    const headerH = Math.min(60, grid.y);
    ctx.save();
    ctx.strokeStyle = 'rgba(255, 200, 0, 0.6)';
    ctx.setLineDash([4, 4]);
    ctx.strokeRect(grid.x, grid.y - headerH, grid.w, headerH);
    ctx.restore();
}

function drawHandle(x, y, color, strokeColor) {
    ctx.beginPath();
    ctx.arc(x, y, 6, 0, Math.PI*2);
    ctx.fillStyle = color;
    ctx.fill();
    if (strokeColor) {
        ctx.strokeStyle = strokeColor;
        ctx.stroke();
    }
}

// --- 3. æ‹–æ‹½äº¤äº’ ---
function getMousePos(e) {
    const rect = canvas.getBoundingClientRect();
    const scaleX = canvas.width / rect.width;
    const scaleY = canvas.height / rect.height;
    return {
        x: (e.clientX - rect.left) * scaleX,
        y: (e.clientY - rect.top) * scaleY
    };
}

const HANDLE_R = 10; // ç‚¹å‡»åˆ¤å®šåŠå¾„

canvas.addEventListener('mousedown', e => {
    const {x, y} = getMousePos(e);
    
    // 1. æ£€æŸ¥åˆ—çº¿æ‰‹æŸ„
    for(let i=0; i<colDividers.length; i++) {
        let lineX = grid.x + colDividers[i] * grid.w;
        // åˆ¤å®šèŒƒå›´åœ¨ Top çº¿é™„è¿‘
        if (dist(x, y, lineX, grid.y) < HANDLE_R) {
            isDragging = true;
            dragTarget = { type: 'divider', index: i };
            return;
        }
    }

    // 2. æ£€æŸ¥å¤–æ¡†æ‰‹æŸ„
    if (dist(x, y, grid.x, grid.y) < HANDLE_R) {
        isDragging = true;
        dragTarget = { type: 'box', handle: 'tl' };
    } else if (dist(x, y, grid.x+grid.w, grid.y+grid.h) < HANDLE_R) {
        isDragging = true;
        dragTarget = { type: 'box', handle: 'br' };
    } else if (x > grid.x && x < grid.x+grid.w && y > grid.y && y < grid.y+grid.h) {
        // 3. æ‹–åŠ¨æ•´ä¸ªæ¡†
        isDragging = true;
        dragTarget = { type: 'move' };
        canvas.lastX = x; canvas.lastY = y;
    }
});

canvas.addEventListener('mousemove', e => {
    const {x, y} = getMousePos(e);
    
    // é¼ æ ‡æ ·å¼
    let cursor = 'default';
    for(let i=0; i<colDividers.length; i++) {
        let lineX = grid.x + colDividers[i] * grid.w;
        if (dist(x, y, lineX, grid.y) < HANDLE_R) cursor = 'col-resize';
    }
    if (dist(x, y, grid.x, grid.y) < HANDLE_R || dist(x,y, grid.x+grid.w, grid.y+grid.h) < HANDLE_R) cursor = 'nwse-resize';
    else if (x > grid.x && x < grid.x+grid.w && y > grid.y && y < grid.y+grid.h && cursor === 'default') cursor = 'move';
    canvas.style.cursor = cursor;

    if (!isDragging) return;

    if (dragTarget.type === 'divider') {
        // æ‹–åŠ¨ç«–çº¿
        let idx = dragTarget.index;
        // è®¡ç®—æ–°çš„æ¯”ä¾‹
        let newRatio = (x - grid.x) / grid.w;
        
        // é™åˆ¶èŒƒå›´ï¼šä¸èƒ½è¶…è¿‡ä¸Šä¸€æ ¹çº¿ï¼Œä¹Ÿä¸èƒ½è¶…è¿‡ä¸‹ä¸€æ ¹çº¿
        let minRatio = (idx === 0) ? 0.01 : colDividers[idx-1] + 0.01;
        let maxRatio = (idx === colDividers.length-1) ? 0.99 : colDividers[idx+1] - 0.01;
        
        newRatio = Math.max(minRatio, Math.min(maxRatio, newRatio));
        colDividers[idx] = newRatio;
        
    } else if (dragTarget.type === 'box') {
        if (dragTarget.handle === 'tl') {
            let oldR = grid.x + grid.w; let oldB = grid.y + grid.h;
            grid.x = x; grid.y = y;
            grid.w = Math.max(10, oldR - grid.x); grid.h = Math.max(10, oldB - grid.y);
        } else {
            grid.w = Math.max(10, x - grid.x);
            grid.h = Math.max(10, y - grid.y);
        }
    } else if (dragTarget.type === 'move') {
        grid.x += x - canvas.lastX;
        grid.y += y - canvas.lastY;
        canvas.lastX = x; canvas.lastY = y;
    }
    
    draw();
});

canvas.addEventListener('mouseup', () => { isDragging = false; dragTarget = null; });
const dist = (x1,y1,x2,y2) => Math.sqrt((x1-x2)**2 + (y1-y2)**2);

// --- 4. å¼ºåˆ¶è·³è¿‡ OCR ---
function forceSkipOCR() { skipOCRFlag = true; }

// --- 5. æ ¸å¿ƒåˆ†æ ---
async function runAnalysis() {
    if(!img.src) { alert("è¯·å…ˆä¸Šä¼ å›¾ç‰‡"); return; }
    
    showLoading(true, "æ­£åœ¨åˆ†æé¢œè‰²...");

    const rows = parseInt(document.getElementById('rowCount').value);
    const cellH = grid.h / rows;
    
    // æ„å»ºåˆ—åŒºé—´ï¼š[0, div1, div2, ..., 1.0]
    let colBoundaries = [0, ...colDividers, 1.0];
    const cols = colBoundaries.length - 1;
    
    // 1. é¢œè‰²åˆ†æ
    rawData = [];
    const imgData = ctx.getImageData(0, 0, canvas.width, canvas.height).data;
    
    for(let r=0; r<rows; r++) {
        let rowData = [];
        let rowY = grid.y + r * cellH;
        
        for(let c=0; c<cols; c++) {
            // è®¡ç®—è¯¥åˆ—çš„å®é™… X èŒƒå›´
            let startRatio = colBoundaries[c];
            let endRatio = colBoundaries[c+1];
            
            let startX = Math.floor(grid.x + startRatio * grid.w);
            let w = Math.floor((endRatio - startRatio) * grid.w);
            let h = Math.floor(cellH);
            
            // é‡‡æ ·åŒºåŸŸï¼šç¼©å°åˆ°ä¸­å¿ƒ 50%
            let sX = startX + w * 0.25;
            let sY = rowY + h * 0.25;
            let sW = w * 0.5;
            let sH = h * 0.5;
            
            if (w < 5) { 
                // é˜²æ­¢æ‹–æ‹½äº§ç”Ÿçš„æçª„åˆ—æŠ¥é”™
                rowData.push(0); continue; 
            }

            let colored = 0, total = 0;
            for(let py=sY; py<sY+sH; py++) {
                for(let px=sX; px<sX+sW; px++) {
                    const i = (Math.floor(py) * canvas.width + Math.floor(px)) * 4;
                    // éç™½åˆ¤æ–­
                    if(imgData[i] < 235 || imgData[i+1] < 235 || imgData[i+2] < 235) colored++;
                    total++;
                }
            }
            // å¯†åº¦ > 5% è§†ä¸ºå…¥ä½
            rowData.push( (colored/total) > 0.05 ? 1 : 0 );
        }
        rawData.push(rowData);
    }

    // 2. OCR (æ”¯æŒä¸ç­‰å®½åˆ—)
    skipOCRFlag = false;
    roomNames = [];
    validCols = Array.from({length: cols}, (_, i) => i);

    try {
        await runVariableWidthOCR(colBoundaries);
    } catch(e) {
        console.warn("OCR Skipped");
        // è¡¥å…¨é»˜è®¤å
        for(let i=roomNames.length; i<cols; i++) roomNames.push(`æˆ¿${i+1}`);
    }

    // 3. æ—¥æœŸ
    dateList = [];
    const startD = new Date(document.getElementById('startDate').value);
    for(let i=0; i<rows; i++) {
        let d = new Date(startD);
        d.setDate(d.getDate() + i);
        dateList.push(`${d.getMonth()+1}/${d.getDate()}`);
    }

    showLoading(false);
    document.getElementById('resultCard').style.display = 'block';
    renderResultTable();
}

async function runVariableWidthOCR(boundaries) {
    const worker = await Tesseract.createWorker();
    document.getElementById('loadingText').innerText = "åŠ è½½è¯­è¨€åŒ…...";
    if(skipOCRFlag) throw "Skip";
    await worker.loadLanguage('chi_sim');
    await worker.initialize('chi_sim');

    const headerH = Math.min(60, grid.y);
    const headerY = grid.y - headerH;
    const cols = boundaries.length - 1;

    for(let c=0; c<cols; c++) {
        if(skipOCRFlag) { await worker.terminate(); throw "Skip"; }
        document.getElementById('loadingText').innerText = `è¯†åˆ«ç¬¬ ${c+1}/${cols} åˆ—...`;

        let r1 = boundaries[c];
        let r2 = boundaries[c+1];
        let cellW = (r2 - r1) * grid.w;
        let cellX = grid.x + r1 * grid.w;
        
        if (cellW < 10) { roomNames.push("ç©º"); continue; }

        const tmpCan = document.createElement('canvas');
        tmpCan.width = cellW; tmpCan.height = headerH;
        const tCtx = tmpCan.getContext('2d');
        
        // ä»åŸå›¾å¯¹åº”æ¯”ä¾‹ä½ç½®ç»˜åˆ¶
        tCtx.drawImage(img,
            cellX / (canvas.width/img.width), headerY / (canvas.height/img.height),
            cellW / (canvas.width/img.width), headerH / (canvas.height/img.height),
            0, 0, cellW, headerH
        );

        const { data: { text } } = await worker.recognize(tmpCan);
        let clean = text.replace(/\s/g, '').replace(/[^\u4e00-\u9fa5a-zA-Z0-9]/g, '');
        roomNames.push(clean || `æˆ¿${c+1}`);
    }
    await worker.terminate();
}

// --- 6. æ¸²æŸ“ä¸å¯¼å‡º ---
function renderResultTable() {
    const table = document.getElementById('dataTable');
    table.innerHTML = '';
    
    // Header
    let thead = document.createElement('thead');
    let tr = document.createElement('tr');
    tr.innerHTML = '<th>æ—¥æœŸ</th>';
    validCols.forEach(idx => {
        let th = document.createElement('th');
        let div = document.createElement('div');
        div.style.display='flex'; div.style.alignItems='center'; div.style.justifyContent='center';
        
        let inp = document.createElement('input');
        inp.className='th-input';
        inp.value = roomNames[idx];
        inp.onchange = (e) => { roomNames[idx] = e.target.value; updateStats(); };
        
        let btn = document.createElement('button');
        btn.className = 'btn-danger';
        btn.innerText = 'X';
        btn.onclick = () => {
            if(confirm("åˆ é™¤æ­¤åˆ—ï¼Ÿ(ä¸å¯æ¢å¤ï¼Œé™¤éé‡æ–°åˆ†æ)")) {
                validCols = validCols.filter(c => c !== idx);
                renderResultTable();
            }
        };
        div.appendChild(inp); div.appendChild(btn);
        th.appendChild(div);
        tr.appendChild(th);
    });
    thead.appendChild(tr);
    table.appendChild(thead);

    // Body
    let tbody = document.createElement('tbody');
    for(let r=0; r<rawData.length; r++) {
        let tr = document.createElement('tr');
        let tdD = document.createElement('td'); tdD.innerText = dateList[r]; tr.appendChild(tdD);
        
        validCols.forEach(c => {
            let td = document.createElement('td');
            if(rawData[r][c]) td.className = 'occupied';
            td.onclick = function() {
                rawData[r][c] = !rawData[r][c];
                this.className = rawData[r][c] ? 'occupied' : '';
                updateStats();
            };
            tr.appendChild(td);
        });
        tbody.appendChild(tr);
    }
    table.appendChild(tbody);
    updateStats();
}

function updateStats() {
    if(validCols.length === 0) return;
    const rows = rawData.length;
    let total = rows * validCols.length;
    let occ = 0;
    
    let roomData = validCols.map(c => {
        let sum = 0; for(let r=0; r<rows; r++) sum += rawData[r][c] ? 1 : 0;
        occ += sum;
        return (sum/rows*100).toFixed(1);
    });
    
    let dayData = [];
    for(let r=0; r<rows; r++) {
        let sum = 0; validCols.forEach(c => sum += rawData[r][c] ? 1 : 0);
        dayData.push((sum/validCols.length*100).toFixed(1));
    }

    document.getElementById('valTotalSlots').innerText = total;
    document.getElementById('valOccupied').innerText = occ;
    document.getElementById('valRate').innerText = (occ/total*100).toFixed(1) + "%";
    
    renderChart(roomData, dayData);
}

function renderChart(rData, dData) {
    const chartDom = document.getElementById('chartMain');
    let myChart = echarts.getInstanceByDom(chartDom);
    if(!myChart) myChart = echarts.init(chartDom);
    
    const names = validCols.map(c => roomNames[c]);
    
    const option = {
        tooltip: { trigger: 'axis' },
        legend: { data: ['æˆ¿é—´å…¥ä½ç‡', 'æ¯æ—¥è¶‹åŠ¿'] },
        grid: { bottom: 80, right: 40, left: 50 },
        xAxis: [
            { type: 'category', data: names, axisLabel: { rotate: 45 } },
            { type: 'category', data: dateList, show: false }
        ],
        yAxis: { type: 'value', max: 100, name: '%' },
        series: [
            { name: 'æˆ¿é—´å…¥ä½ç‡', type: 'bar', data: rData, itemStyle:{color:'#0071e3'}, label:{show:true, position:'top', formatter:'{c}%'} },
            { name: 'æ¯æ—¥è¶‹åŠ¿', type: 'line', smooth:true, data: dData, xAxisIndex:0, itemStyle:{color:'#34c759'} } // ç®€åŒ–æ˜¾ç¤ºå…±ç”¨Xè½´
        ]
    };
    myChart.setOption(option);
}

function switchTab(mode) {
    document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
    event.target.classList.add('active');
    document.getElementById('viewTable').style.display = mode === 'table' ? 'block' : 'none';
    document.getElementById('viewChart').style.display = mode === 'chart' ? 'block' : 'none';
    const chart = echarts.getInstanceByDom(document.getElementById('chartMain'));
    if(mode === 'chart' && chart) setTimeout(() => chart.resize(), 100);
}

function exportExcel() {
    let wb = XLSX.utils.book_new();
    let wsData = [];
    let h = ['æ—¥æœŸ']; validCols.forEach(c => h.push(roomNames[c])); h.push('å½“æ—¥å…¥ä½ç‡');
    wsData.push(h);
    
    for(let r=0; r<rawData.length; r++) {
        let row = [dateList[r]];
        let sum = 0;
        validCols.forEach(c => {
            row.push(rawData[r][c] ? 1 : '');
            if(rawData[r][c]) sum++;
        });
        row.push((sum/validCols.length*100).toFixed(1)+'%');
        wsData.push(row);
    }
    let ws = XLSX.utils.aoa_to_sheet(wsData);
    XLSX.utils.book_append_sheet(wb, ws, "å…¥ä½æ•°æ®");
    XLSX.writeFile(wb, "å…¥ä½ç‡åˆ†æ.xlsx");
}

function showLoading(show, text) {
    document.getElementById('loading').style.display = show ? 'flex' : 'none';
    if(text) document.getElementById('loadingText').innerText = text;
}
window.onresize = () => { initCanvas(); const c = echarts.getInstanceByDom(document.getElementById('chartMain')); if(c) c.resize(); };
</script>
</body>
</html>
